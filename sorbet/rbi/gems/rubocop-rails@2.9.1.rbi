# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rails` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rails`.

# source://rubocop-rails//lib/rubocop/rails.rb#3
module RuboCop; end

# source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#4
module RuboCop::Cop; end

# A mixin to extend cops for Active Record features
#
# source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#6
module RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#19
  def external_dependency_checksum; end

  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#15
  def find_belongs_to(param0); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#11
  def find_set_table_name(param0); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#68
  def foreign_key_of(belongs_to); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#80
  def in_where?(node); end

  # Resolve relation into column name.
  # It just returns column_name if the column exists.
  # Or it tries to resolve column_name as a relation.
  # It returns `nil` if it can't resolve.
  #
  # @param name [String]
  # @param class_node [RuboCop::AST::Node]
  # @param table [RuboCop::Rails::SchemaLoader::Table]
  # @return [String, nil]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#55
  def resolve_relation_into_column(name:, class_node:, table:); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#30
  def schema; end

  # source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#34
  def table_name(class_node); end
end

# source://rubocop-rails//lib/rubocop/cop/mixin/active_record_helper.rb#9
RuboCop::Cop::ActiveRecordHelper::WHERE_METHODS = T.let(T.unsafe(nil), Array)

# Common functionality for enforcing a specific superclass.
#
# source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#6
module RuboCop::Cop::EnforceSuperclass
  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#19
  def on_class(node); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#25
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#33
  def register_offense(offense_node); end

  class << self
    # @private
    #
    # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#7
    def included(base); end
  end
end

# Common functionality for Rails/IndexBy and Rails/IndexWith
#
# source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#6
module RuboCop::Cop::IndexMethod
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#9
  def on_block(node); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#31
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#21
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#95
  def execute_correction(corrector, node, correction); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#72
  def extract_captures(match); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#59
  def handle_possible_offense(node, match, match_desc); end

  # @raise [NotImplementedError]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#77
  def new_method_name; end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#40
  def on_bad_each_with_object(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#55
  def on_bad_hash_brackets_map(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#50
  def on_bad_map_to_h(_node); end

  # @abstract Implemented with `def_node_matcher`
  # @raise [NotImplementedError]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#45
  def on_bad_to_h(_node); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#81
  def prepare_correction(node); end
end

# Internal helper class to hold autocorrect data
#
# source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#119
class RuboCop::Cop::IndexMethod::Autocorrection < ::Struct
  # Returns the value of attribute block_node
  #
  # @return [Object] the current value of block_node
  def block_node; end

  # Sets the attribute block_node
  #
  # @param value [Object] the value to set the attribute block_node to.
  # @return [Object] the newly set value
  def block_node=(_); end

  # Returns the value of attribute leading
  #
  # @return [Object] the current value of leading
  def leading; end

  # Sets the attribute leading
  #
  # @param value [Object] the value to set the attribute leading to.
  # @return [Object] the newly set value
  def leading=(_); end

  # Returns the value of attribute match
  #
  # @return [Object] the current value of match
  def match; end

  # Sets the attribute match
  #
  # @param value [Object] the value to set the attribute match to.
  # @return [Object] the newly set value
  def match=(_); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#159
  def set_new_arg_name(transformed_argname, corrector); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#166
  def set_new_body_expression(transforming_body_expr, corrector); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#150
  def set_new_method_name(new_method_name, corrector); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#144
  def strip_prefix_and_suffix(node, corrector); end

  # Returns the value of attribute trailing
  #
  # @return [Object] the current value of trailing
  def trailing; end

  # Sets the attribute trailing
  #
  # @param value [Object] the value to set the attribute trailing to.
  # @return [Object] the newly set value
  def trailing=(_); end

  class << self
    def [](*_arg0); end

    # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#120
    def from_each_with_object(node, match); end

    # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#140
    def from_hash_brackets_map(node, match); end

    # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#128
    def from_map_to_h(node, match); end

    # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#124
    def from_to_h(node, match); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Internal helper class to hold match data
#
# source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#108
class RuboCop::Cop::IndexMethod::Captures < ::Struct
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#112
  def noop_transformation?; end

  # Returns the value of attribute transformed_argname
  #
  # @return [Object] the current value of transformed_argname
  def transformed_argname; end

  # Sets the attribute transformed_argname
  #
  # @param value [Object] the value to set the attribute transformed_argname to.
  # @return [Object] the newly set value
  def transformed_argname=(_); end

  # Returns the value of attribute transforming_body_expr
  #
  # @return [Object] the current value of transforming_body_expr
  def transforming_body_expr; end

  # Sets the attribute transforming_body_expr
  #
  # @param value [Object] the value to set the attribute transforming_body_expr to.
  # @return [Object] the newly set value
  def transforming_body_expr=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://rubocop-rails//lib/rubocop/cop/mixin/index_method.rb#7
RuboCop::Cop::IndexMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#5
module RuboCop::Cop::Rails; end

# This cop enforces the consistent use of action filter methods.
#
# The cop is configurable and can enforce the use of the older
# something_filter methods or the newer something_action methods.
#
# @example EnforcedStyle: action (default)
#   # bad
#   after_filter :do_stuff
#   append_around_filter :do_stuff
#   skip_after_filter :do_stuff
#
#   # good
#   after_action :do_stuff
#   append_around_action :do_stuff
#   skip_after_action :do_stuff
# @example EnforcedStyle: filter
#   # bad
#   after_action :do_stuff
#   append_around_action :do_stuff
#   skip_after_action :do_stuff
#
#   # good
#   after_filter :do_stuff
#   append_around_filter :do_stuff
#   skip_after_filter :do_stuff
#
# source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#32
class RuboCop::Cop::Rails::ActionFilter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#72
  def on_block(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#76
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#93
  def bad_methods; end

  # source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#82
  def check_method_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#97
  def good_methods; end

  # source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#101
  def preferred_method(method); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#54
RuboCop::Cop::Rails::ActionFilter::ACTION_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#38
RuboCop::Cop::Rails::ActionFilter::FILTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#36
RuboCop::Cop::Rails::ActionFilter::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/action_filter.rb#70
RuboCop::Cop::Rails::ActionFilter::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that ActiveRecord aliases are not used. The direct method names
# are more clear and easier to read.
#
# @example
#   #bad
#   Book.update_attributes!(author: 'Alice')
#
#   #good
#   Book.update!(author: 'Alice')
#
# source://rubocop-rails//lib/rubocop/cop/rails/active_record_aliases.rb#15
class RuboCop::Cop::Rails::ActiveRecordAliases < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_aliases.rb#27
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_aliases.rb#27
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_aliases.rb#20
RuboCop::Cop::Rails::ActiveRecordAliases::ALIASES = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_aliases.rb#18
RuboCop::Cop::Rails::ActiveRecordAliases::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_aliases.rb#25
RuboCop::Cop::Rails::ActiveRecordAliases::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that Active Record callbacks are declared
# in the order in which they will be executed.
#
# @example
#   # bad
#   class Person < ApplicationRecord
#   after_commit :after_commit_callback
#   before_validation :before_validation_callback
#   end
#
#   # good
#   class Person < ApplicationRecord
#   before_validation :before_validation_callback
#   after_commit :after_commit_callback
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#22
class RuboCop::Cop::Rails::ActiveRecordCallbacksOrder < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#51
  def on_class(class_node); end

  private

  # Autocorrect by swapping between two nodes autocorrecting them
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#73
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#119
  def begin_pos_with_comment(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#142
  def buffer; end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#95
  def callback?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#85
  def defined_callbacks(class_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#114
  def end_position_for(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#134
  def inline_comment?(comment); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#99
  def left_siblings_of(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#103
  def siblings_of(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#107
  def source_range_with_comment(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#138
  def start_line_position(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#27
RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::CALLBACKS_IN_ORDER = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#49
RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::CALLBACKS_ORDER_MAP = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_callbacks_order.rb#25
RuboCop::Cop::Rails::ActiveRecordCallbacksOrder::MSG = T.let(T.unsafe(nil), String)

# Checks for overriding built-in Active Record methods instead of using
# callbacks.
#
# @example
#   # bad
#   class Book < ApplicationRecord
#   def save
#   self.title = title.upcase!
#   super
#   end
#   end
#
#   # good
#   class Book < ApplicationRecord
#   before_save :upcase_title
#
#   def upcase_title
#   self.title = title.upcase!
#   end
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#27
class RuboCop::Cop::Rails::ActiveRecordOverride < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#35
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#48
  def active_model?(parent_class_name); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#52
  def callback_names(method_name); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#66
  def find_parent_class_name(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#62
  def message(method_name); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#32
RuboCop::Cop::Rails::ActiveRecordOverride::ACTIVE_RECORD_CLASSES = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#31
RuboCop::Cop::Rails::ActiveRecordOverride::BAD_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/active_record_override.rb#28
RuboCop::Cop::Rails::ActiveRecordOverride::MSG = T.let(T.unsafe(nil), String)

# This cop checks that ActiveSupport aliases to core ruby methods
# are not used.
#
# @example
#   # good
#   'some_string'.start_with?('prefix')
#   'some_string'.end_with?('suffix')
#   [1, 2, 'a'] << 'b'
#   [1, 2, 'a'].unshift('b')
#
#   # bad
#   'some_string'.starts_with?('prefix')
#   'some_string'.ends_with?('suffix')
#   [1, 2, 'a'].append('b')
#   [1, 2, 'a'].prepend('b')
#
# source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#22
class RuboCop::Cop::Rails::ActiveSupportAliases < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#40
  def append(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#40
  def ends_with?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#43
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#40
  def prepend(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#40
  def starts_with?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#28
RuboCop::Cop::Rails::ActiveSupportAliases::ALIASES = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#25
RuboCop::Cop::Rails::ActiveSupportAliases::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/active_support_aliases.rb#26
RuboCop::Cop::Rails::ActiveSupportAliases::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that there is only one call to `after_commit`
# (and its aliases - `after_create_commit`, `after_update_commit`,
# and `after_destroy_commit`) with the same callback name per model.
#
# @example
#   # bad
#   # This won't be triggered.
#   after_create_commit :log_action
#
#   # This will override the callback added by
#   # after_create_commit.
#   after_update_commit :log_action
#
#   # bad
#   # This won't be triggered.
#   after_commit :log_action, on: :create
#   # This won't be triggered.
#   after_update_commit :log_action
#   # This will override both previous callbacks.
#   after_commit :log_action, on: :destroy
#
#   # good
#   after_save_commit :log_action
#
#   # good
#   after_create_commit :log_create_action
#   after_update_commit :log_update_action
#
# source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#34
class RuboCop::Cop::Rails::AfterCommitOverride < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#45
  def on_class(class_node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#78
  def after_commit_callback?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#66
  def class_send_nodes(class_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#60
  def each_after_commit_callback(class_node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#82
  def named_callback?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#37
RuboCop::Cop::Rails::AfterCommitOverride::AFTER_COMMIT_CALLBACKS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/after_commit_override.rb#35
RuboCop::Cop::Rails::AfterCommitOverride::MSG = T.let(T.unsafe(nil), String)

# This cop checks that controllers subclass ApplicationController.
#
# @example
#
#   # good
#   class MyController < ApplicationController
#   # ...
#   end
#
#   # bad
#   class MyController < ActionController::Base
#   # ...
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/application_controller.rb#19
class RuboCop::Cop::Rails::ApplicationController < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#8
  def class_definition(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#12
  def class_new_definition(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/application_controller.rb#24
RuboCop::Cop::Rails::ApplicationController::BASE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_controller.rb#22
RuboCop::Cop::Rails::ApplicationController::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_controller.rb#23
RuboCop::Cop::Rails::ApplicationController::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that jobs subclass ApplicationJob with Rails 5.0.
#
# @example
#
#   # good
#   class Rails5Job < ApplicationJob
#   # ...
#   end
#
#   # bad
#   class Rails4Job < ActiveJob::Base
#   # ...
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/application_job.rb#19
class RuboCop::Cop::Rails::ApplicationJob < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/application_job.rb#33
  def autocorrect(node); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#8
  def class_definition(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#12
  def class_new_definition(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/application_job.rb#27
RuboCop::Cop::Rails::ApplicationJob::BASE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_job.rb#25
RuboCop::Cop::Rails::ApplicationJob::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_job.rb#26
RuboCop::Cop::Rails::ApplicationJob::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that mailers subclass ApplicationMailer with Rails 5.0.
#
# @example
#
#   # good
#   class MyMailer < ApplicationMailer
#   # ...
#   end
#
#   # bad
#   class MyMailer < ActionMailer::Base
#   # ...
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/application_mailer.rb#19
class RuboCop::Cop::Rails::ApplicationMailer < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#8
  def class_definition(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#12
  def class_new_definition(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/application_mailer.rb#27
RuboCop::Cop::Rails::ApplicationMailer::BASE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_mailer.rb#25
RuboCop::Cop::Rails::ApplicationMailer::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_mailer.rb#26
RuboCop::Cop::Rails::ApplicationMailer::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop checks that models subclass ApplicationRecord with Rails 5.0.
#
# @example
#
#   # good
#   class Rails5Model < ApplicationRecord
#   # ...
#   end
#
#   # bad
#   class Rails4Model < ActiveRecord::Base
#   # ...
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/application_record.rb#19
class RuboCop::Cop::Rails::ApplicationRecord < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EnforceSuperclass
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#8
  def class_definition(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/mixin/enforce_superclass.rb#12
  def class_new_definition(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/application_record.rb#27
RuboCop::Cop::Rails::ApplicationRecord::BASE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_record.rb#25
RuboCop::Cop::Rails::ApplicationRecord::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/application_record.rb#26
RuboCop::Cop::Rails::ApplicationRecord::SUPERCLASS = T.let(T.unsafe(nil), String)

# This cop prevents usage of `"*"` on an Arel::Table column reference.
#
# Using `arel_table["*"]` causes the outputted string to be a literal
# quoted asterisk (e.g. <tt>`my_model`.`*`</tt>). This causes the
# database to look for a column named <tt>`*`</tt> (or `"*"`) as opposed
# to expanding the column list as one would likely expect.
#
# @example
#   # bad
#   MyTable.arel_table["*"]
#
#   # good
#   MyTable.arel_table[Arel.star]
#
# source://rubocop-rails//lib/rubocop/cop/rails/arel_star.rb#20
class RuboCop::Cop::Rails::ArelStar < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/arel_star.rb#31
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/arel_star.rb#27
  def star_bracket?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/arel_star.rb#23
RuboCop::Cop::Rails::ArelStar::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/arel_star.rb#25
RuboCop::Cop::Rails::ArelStar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use `assert_not` instead of `assert !`.
#
# @example
#   # bad
#   assert !x
#
#   # good
#   assert_not x
#
# source://rubocop-rails//lib/rubocop/cop/rails/assert_not.rb#16
class RuboCop::Cop::Rails::AssertNot < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/assert_not.rb#22
  def offensive?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/assert_not.rb#24
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/assert_not.rb#36
  def corrected_source(source); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/assert_not.rb#19
RuboCop::Cop::Rails::AssertNot::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/assert_not.rb#20
RuboCop::Cop::Rails::AssertNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for `attribute` class methods that specify a `:default` option
# which value is an array, string literal or method call without a block.
# It will accept all other values, such as string, symbol, integer and float literals
# as well as constants.
#
# @example
#   # bad
#   class User < ApplicationRecord
#   attribute :confirmed_at, :datetime, default: Time.zone.now
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :confirmed_at, :datetime, default: -> { Time.zone.now }
#   end
#
#   # bad
#   class User < ApplicationRecord
#   attribute :roles, :string, array: true, default: []
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :roles, :string, array: true, default: -> { [] }
#   end
#
#   # bad
#   class User < ApplicationRecord
#   attribute :configuration, default: {}
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :configuration, default: -> { {} }
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :role, :string, default: :customer
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :activated, :boolean, default: false
#   end
#
#   # good
#   class User < ApplicationRecord
#   attribute :login_count, :integer, default: 0
#   end
#
#   # good
#   class User < ApplicationRecord
#   FOO = 123
#   attribute :custom_attribute, :integer, default: FOO
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#62
class RuboCop::Cop::Rails::AttributeDefaultBlockValue < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#73
  def attribute(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#69
  def default_attribute(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#75
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#65
RuboCop::Cop::Rails::AttributeDefaultBlockValue::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#66
RuboCop::Cop::Rails::AttributeDefaultBlockValue::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/attribute_default_block_value.rb#67
RuboCop::Cop::Rails::AttributeDefaultBlockValue::TYPE_OFFENDERS = T.let(T.unsafe(nil), Array)

# This cop looks for belongs_to associations where we control whether the
# association is required via the deprecated `required` option instead.
#
# Since Rails 5, belongs_to associations are required by default and this
# can be controlled through the use of `optional: true`.
#
# From the release notes:
#
#     belongs_to will now trigger a validation error by default if the
#     association is not present. You can turn this off on a
#     per-association basis with optional: true. Also deprecate required
#     option in favor of optional for belongs_to. (Pull Request)
#
# In the case that the developer is doing `required: false`, we
# definitely want to autocorrect to `optional: true`.
#
# However, without knowing whether they've set overridden the default
# value of `config.active_record.belongs_to_required_by_default`, we
# can't say whether it's safe to remove `required: true` or whether we
# should replace it with `optional: false` (or, similarly, remove a
# superfluous `optional: false`). Therefore, in the cases we're using
# `required: true`, we'll simply invert it to `optional: false` and the
# user can remove depending on their defaults.
#
# @example
#   # bad
#   class Post < ApplicationRecord
#   belongs_to :blog, required: false
#   end
#
#   # good
#   class Post < ApplicationRecord
#   belongs_to :blog, optional: true
#   end
#
#   # bad
#   class Post < ApplicationRecord
#   belongs_to :blog, required: true
#   end
#
#   # good
#   class Post < ApplicationRecord
#   belongs_to :blog, optional: false
#   end
# @see https://guides.rubyonrails.org/5_0_release_notes.html
# @see https://github.com/rails/rails/pull/18937
#
# source://rubocop-rails//lib/rubocop/cop/rails/belongs_to.rb#53
class RuboCop::Cop::Rails::BelongsTo < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/belongs_to.rb#70
  def match_belongs_to_with_options(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/belongs_to.rb#76
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/belongs_to.rb#68
RuboCop::Cop::Rails::BelongsTo::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/belongs_to.rb#59
RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_FALSE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/belongs_to.rb#63
RuboCop::Cop::Rails::BelongsTo::SUPERFLOUS_REQUIRE_TRUE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for code that can be written with simpler conditionals
# using `Object#blank?` defined by Active Support.
#
# Interaction with `Style/UnlessElse`:
# The configuration of `NotPresent` will not produce an offense in the
# context of `unless else` if `Style/UnlessElse` is inabled. This is
# to prevent interference between the auto-correction of the two cops.
#
# @example NilOrEmpty: true (default)
#   # Converts usages of `nil? || empty?` to `blank?`
#
#   # bad
#   foo.nil? || foo.empty?
#   foo == nil || foo.empty?
#
#   # good
#   foo.blank?
# @example NotPresent: true (default)
#   # Converts usages of `!present?` to `blank?`
#
#   # bad
#   !foo.present?
#
#   # good
#   foo.blank?
# @example UnlessPresent: true (default)
#   # Converts usages of `unless present?` to `if blank?`
#
#   # bad
#   something unless foo.present?
#
#   # good
#   something if foo.blank?
#
#   # bad
#   unless foo.present?
#   something
#   end
#
#   # good
#   if foo.blank?
#   something
#   end
#
#   # good
#   def blank?
#   !present?
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#56
class RuboCop::Cop::Rails::Blank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#86
  def defining_blank?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#69
  def nil_or_empty?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#84
  def not_present?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#119
  def on_if(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#106
  def on_or(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#92
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#88
  def unless_present?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#136
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#158
  def replacement(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#150
  def unless_condition(node, method_call); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#59
RuboCop::Cop::Rails::Blank::MSG_NIL_OR_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#60
RuboCop::Cop::Rails::Blank::MSG_NOT_PRESENT = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#61
RuboCop::Cop::Rails::Blank::MSG_UNLESS_PRESENT = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/blank.rb#63
RuboCop::Cop::Rails::Blank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This Cop checks whether alter queries are combinable.
# If combinable queries are detected, it suggests to you
# to use `change_table` with `bulk: true` instead.
# This option causes the migration to generate a single
# ALTER TABLE statement combining multiple column alterations.
#
# The `bulk` option is only supported on the MySQL and
# the PostgreSQL (5.2 later) adapter; thus it will
# automatically detect an adapter from `development` environment
# in `config/database.yml` when the `Database` option is not set.
# If the adapter is not `mysql2` or `postgresql`,
# this Cop ignores offenses.
#
# @example
#   # bad
#   def change
#   add_column :users, :name, :string, null: false
#   add_column :users, :nickname, :string
#
#   # ALTER TABLE `users` ADD `name` varchar(255) NOT NULL
#   # ALTER TABLE `users` ADD `nickname` varchar(255)
#   end
#
#   # good
#   def change
#   change_table :users, bulk: true do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#
#   # ALTER TABLE `users` ADD `name` varchar(255) NOT NULL,
#   #                     ADD `nickname` varchar(255)
#   end
# @example
#   # bad
#   def change
#   change_table :users do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
#
#   # good
#   def change
#   change_table :users, bulk: true do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
#
#   # good
#   # When you don't want to combine alter queries.
#   def change
#   change_table :users, bulk: false do |t|
#   t.string :name, null: false
#   t.string :nickname
#   end
#   end
# @see https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table
# @see https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html
#
# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#68
class RuboCop::Cop::Rails::BulkChangeTable < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#134
  def on_def(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#152
  def on_send(node); end

  private

  # @param node [RuboCop::AST::SendNode]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#245
  def add_offense_for_alter_methods(node); end

  # @param node [RuboCop::AST::SendNode]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#255
  def add_offense_for_change_table(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#221
  def call_to_combinable_alter_method?(child_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#226
  def combinable_alter_methods; end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#235
  def combinable_transformations; end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#179
  def database; end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#183
  def database_from_yaml; end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#194
  def database_yaml; end

  # @param node [RuboCop::AST::SendNode] (send nil? :change_table ...)
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#170
  def include_bulk_options?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#208
  def support_bulk_alter?; end
end

# Record combinable alter methods and register offensive nodes.
#
# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#260
class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  # @return [AlterMethodsRecorder] a new instance of AlterMethodsRecorder
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#261
  def initialize; end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#280
  def flush; end

  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#285
  def offensive_nodes; end

  # @param new_node [RuboCop::AST::SendNode]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#267
  def process(new_node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#105
RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#81
RuboCop::Cop::Rails::BulkChangeTable::COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#79
RuboCop::Cop::Rails::BulkChangeTable::MIGRATION_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#72
RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_ALTER_METHODS = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#69
RuboCop::Cop::Rails::BulkChangeTable::MSG_FOR_CHANGE_TABLE = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#76
RuboCop::Cop::Rails::BulkChangeTable::MYSQL = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#120
RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#114
RuboCop::Cop::Rails::BulkChangeTable::MYSQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#77
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#130
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_ALTER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/bulk_change_table.rb#126
RuboCop::Cop::Rails::BulkChangeTable::POSTGRESQL_COMBINABLE_TRANSFORMATIONS = T.let(T.unsafe(nil), Array)

# This cop checks that `tag` is used instead of `content_tag`
# because `content_tag` is legacy syntax.
#
# NOTE: Allow `content_tag` when the first argument is a variable because
#      `content_tag(name)` is simpler rather than `tag.public_send(name)`.
#
# @example
#   # bad
#   content_tag(:p, 'Hello world!')
#   content_tag(:br)
#
#   # good
#   tag.p('Hello world!')
#   tag.br
#   content_tag(name, 'Hello world!')
#
# source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#21
class RuboCop::Cop::Rails::ContentTag < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#31
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#44
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#63
  def correction_range(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#57
  def method_name?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#28
RuboCop::Cop::Rails::ContentTag::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/content_tag.rb#29
RuboCop::Cop::Rails::ContentTag::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks the migration for which timestamps are not included
# when creating a new table.
# In many cases, timestamps are useful information and should be added.
#
# @example
#   # bad
#   create_table :users
#
#   # bad
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.timestamps
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.datetime :created_at, default: -> { 'CURRENT_TIMESTAMP' }
#   end
#
#   # good
#   create_table :users do |t|
#   t.string :name
#   t.string :email
#
#   t.datetime :updated_at, default: -> { 'CURRENT_TIMESTAMP' }
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#43
class RuboCop::Cop::Rails::CreateTableWithTimestamps < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#47
  def create_table_with_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#54
  def create_table_with_timestamps_proc?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#62
  def created_at_or_updated_at_included?(param0); end

  # source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#68
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#58
  def timestamps_included?(param0); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#84
  def time_columns_included?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#44
RuboCop::Cop::Rails::CreateTableWithTimestamps::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/create_table_with_timestamps.rb#45
RuboCop::Cop::Rails::CreateTableWithTimestamps::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the correct use of Date methods,
# such as Date.today, Date.current etc.
#
# Using `Date.today` is dangerous, because it doesn't know anything about
# Rails time zone. You must use `Time.zone.today` instead.
#
# The cop also reports warnings when you are using `to_time` method,
# because it doesn't know about Rails time zone either.
#
# Two styles are supported for this cop. When EnforcedStyle is 'strict'
# then the Date methods `today`, `current`, `yesterday`, and `tomorrow`
# are prohibited and the usage of both `to_time`
# and 'to_time_in_current_zone' are reported as warning.
#
# When EnforcedStyle is 'flexible' then only `Date.today` is prohibited
# and only `to_time` is reported as warning.
#
# @example EnforcedStyle: strict
#   # bad
#   Date.current
#   Date.yesterday
#   Date.today
#   date.to_time
#
#   # good
#   Time.zone.today
#   Time.zone.today - 1.day
# @example EnforcedStyle: flexible (default)
#   # bad
#   Date.today
#   date.to_time
#
#   # good
#   Time.zone.today
#   Time.zone.today - 1.day
#   Date.current
#   Date.yesterday
#   date.in_time_zone
#
# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#46
class RuboCop::Cop::Rails::Date < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#66
  def on_const(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#74
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#74
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#146
  def bad_days; end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#150
  def bad_methods; end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#97
  def check_date_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#87
  def check_deprecated_methods(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#112
  def extract_method_chain(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#142
  def good_days; end

  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#154
  def good_methods; end

  # checks that parent node of send_type
  # and receiver is the given node
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#118
  def method_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#124
  def safe_chain?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/date.rb#130
  def safe_to_time?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#57
RuboCop::Cop::Rails::Date::BAD_DAYS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#59
RuboCop::Cop::Rails::Date::DEPRECATED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#63
RuboCop::Cop::Rails::Date::DEPRECATED_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#49
RuboCop::Cop::Rails::Date::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#52
RuboCop::Cop::Rails::Date::MSG_SEND = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/date.rb#55
RuboCop::Cop::Rails::Date::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for uses of `default_scope`.
#
# @example
#   # bad
#   default_scope -> { where(hidden: false) }
#
#   # good
#   scope :published, -> { where(hidden: false) }
#
#   # bad
#   def self.default_scope
#   where(hidden: false)
#   end
#
#   # good
#   def self.published
#   where(hidden: false)
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#25
class RuboCop::Cop::Rails::DefaultScope < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#33
  def class_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#37
  def eigenclass_method_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#29
  def method_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#47
  def on_defs(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#53
  def on_sclass(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#41
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#26
RuboCop::Cop::Rails::DefaultScope::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/default_scope.rb#27
RuboCop::Cop::Rails::DefaultScope::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for delegations that could have been created
# automatically with the `delegate` method.
#
# Safe navigation `&.` is ignored because Rails' `allow_nil`
# option checks not just for nil but also delegates if nil
# responds to the delegated method.
#
# The `EnforceForPrefixed` option (defaulted to `true`) means that
# using the target object as a prefix of the method name
# without using the `delegate` method will be a violation.
# When set to `false`, this case is legal.
#
# @example
#   # bad
#   def bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo
#
#   # good
#   def bar
#   foo&.bar
#   end
#
#   # good
#   private
#   def bar
#   foo.bar
#   end
# @example EnforceForPrefixed: true (default)
#   # bad
#   def foo_bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo, prefix: true
# @example EnforceForPrefixed: false
#   # good
#   def foo_bar
#   foo.bar
#   end
#
#   # good
#   delegate :bar, to: :foo, prefix: true
#
# source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#55
class RuboCop::Cop::Rails::Delegate < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#60
  def delegate?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#65
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#89
  def arguments_match?(arg_array, body); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#106
  def include_prefix_case?; end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#101
  def method_name_matches?(method_name, body); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#110
  def prefixed_method_name(body); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#120
  def private_or_protected_before(line); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#114
  def private_or_protected_delegation(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#124
  def private_or_protected_inline(line); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#74
  def register_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#83
  def trivial_delegate?(def_node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/delegate.rb#58
RuboCop::Cop::Rails::Delegate::MSG = T.let(T.unsafe(nil), String)

# This cop looks for delegations that pass :allow_blank as an option
# instead of :allow_nil. :allow_blank is not a valid option to pass
# to ActiveSupport#delegate.
#
# @example
#   # bad
#   delegate :foo, to: :bar, allow_blank: true
#
#   # good
#   delegate :foo, to: :bar, allow_nil: true
#
# source://rubocop-rails//lib/rubocop/cop/rails/delegate_allow_blank.rb#16
class RuboCop::Cop::Rails::DelegateAllowBlank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate_allow_blank.rb#22
  def allow_blank_option(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/delegate_allow_blank.rb#26
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/delegate_allow_blank.rb#19
RuboCop::Cop::Rails::DelegateAllowBlank::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/delegate_allow_blank.rb#20
RuboCop::Cop::Rails::DelegateAllowBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks dynamic `find_by_*` methods.
# Use `find_by` instead of dynamic method.
# See. https://rails.rubystyle.guide#find_by
#
# @example
#   # bad
#   User.find_by_name(name)
#   User.find_by_name_and_email(name)
#   User.find_by_email!(name)
#
#   # good
#   User.find_by(name: name)
#   User.find_by(name: name, email: email)
#   User.find_by!(email: email)
# @example AllowedMethods: find_by_sql
#   # bad
#   User.find_by_query(users_query)
#
#   # good
#   User.find_by_sql(users_sql)
# @example AllowedReceivers: Gem::Specification
#   # bad
#   Specification.find_by_name('backend').gem_dir
#
#   # good
#   Gem::Specification.find_by_name('backend').gem_dir
#
# source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#34
class RuboCop::Cop::Rails::DynamicFindBy < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#40
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#40
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#66
  def allowed_invocation?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#71
  def allowed_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#77
  def allowed_receiver?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#57
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#96
  def autocorrect_argument_keywords(corrector, node, keywords); end

  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#91
  def autocorrect_method_name(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#102
  def column_keywords(method); end

  # Returns static method name.
  # If code isn't wrong, returns nil
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#109
  def static_method_name(method_name); end

  # config option `WhiteList` will be deprecated soon
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#84
  def whitelisted?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#38
RuboCop::Cop::Rails::DynamicFindBy::METHOD_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rails//lib/rubocop/cop/rails/dynamic_find_by.rb#37
RuboCop::Cop::Rails::DynamicFindBy::MSG = T.let(T.unsafe(nil), String)

# This cop looks for enums written with array syntax.
#
# When using array syntax, adding an element in a
# position other than the last causes all previous
# definitions to shift. Explicitly specifying the
# value for each key prevents this from happening.
#
# @example
#   # bad
#   enum status: [:active, :archived]
#
#   # good
#   enum status: { active: 0, archived: 1 }
#
# source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#20
class RuboCop::Cop::Rails::EnumHash < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#31
  def array_pair?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#27
  def enum?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#35
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#54
  def enum_name(key); end

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#63
  def source(elem); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#23
RuboCop::Cop::Rails::EnumHash::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/enum_hash.rb#25
RuboCop::Cop::Rails::EnumHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for duplicate values in enum declarations.
#
# @example
#   # bad
#   enum status: { active: 0, archived: 0 }
#
#   # good
#   enum status: { active: 0, archived: 1 }
#
#   # bad
#   enum status: [:active, :archived, :active]
#
#   # good
#   enum status: [:active, :archived]
#
# source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#20
class RuboCop::Cop::Rails::EnumUniqueness < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Duplication

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#27
  def enum?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#31
  def enum_values(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#35
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#55
  def enum_name(key); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#23
RuboCop::Cop::Rails::EnumUniqueness::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/enum_uniqueness.rb#25
RuboCop::Cop::Rails::EnumUniqueness::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that Rails.env is compared using `.production?`-like
# methods instead of equality against a string or symbol.
#
# @example
#   # bad
#   Rails.env == 'production'
#
#   # bad, always returns false
#   Rails.env == :test
#
#   # good
#   Rails.env.production?
#
# source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#18
class RuboCop::Cop::Rails::EnvironmentComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#28
  def comparing_str_env_with_rails_env_on_lhs?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#36
  def comparing_str_env_with_rails_env_on_rhs?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#44
  def comparing_sym_env_with_rails_env_on_lhs?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#52
  def comparing_sym_env_with_rails_env_on_rhs?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#60
  def content(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#64
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#85
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#91
  def build_predicate_method(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#104
  def build_predicate_method_for_rails_env_on_lhs(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#110
  def build_predicate_method_for_rails_env_on_rhs(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#99
  def rails_env_on_lhs?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#21
RuboCop::Cop::Rails::EnvironmentComparison::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#26
RuboCop::Cop::Rails::EnvironmentComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/environment_comparison.rb#23
RuboCop::Cop::Rails::EnvironmentComparison::SYM_MSG = T.let(T.unsafe(nil), String)

# This cop enforces that `exit` calls are not used within a rails app.
# Valid options are instead to raise an error, break, return, or some
# other form of stopping execution of current request.
#
# There are two obvious cases where `exit` is particularly harmful:
#
# * Usage in library code for your application. Even though Rails will
# rescue from a `SystemExit` and continue on, unit testing that library
# code will result in specs exiting (potentially silently if `exit(0)`
# is used.)
# * Usage in application code outside of the web process could result in
# the program exiting, which could result in the code failing to run and
# do its job.
#
# @example
#   # bad
#   exit(0)
#
#   # good
#   raise 'a bad error has happened'
#
# source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#26
class RuboCop::Cop::Rails::Exit < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#33
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#39
  def offending_node?(node); end

  # More than 1 argument likely means it is a different
  # `exit` implementation than the one we are preventing.
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#45
  def right_argument_count?(arg_nodes); end

  # Only register if exit is being called explicitly on `Kernel`,
  # `Process`, or if receiver node is nil for plain `exit` calls.
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#51
  def right_receiver?(receiver_node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#31
RuboCop::Cop::Rails::Exit::EXPLICIT_RECEIVERS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#29
RuboCop::Cop::Rails::Exit::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/exit.rb#30
RuboCop::Cop::Rails::Exit::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of file path joining process
# to use `Rails.root.join` clause. It is used to add uniformity when
# joining paths.
#
# @example EnforcedStyle: arguments
#   # bad
#   Rails.root.join('app/models/goober')
#   File.join(Rails.root, 'app/models/goober')
#   "#{Rails.root}/app/models/goober"
#
#   # good
#   Rails.root.join('app', 'models', 'goober')
# @example EnforcedStyle: slashes (default)
#   # bad
#   Rails.root.join('app', 'models', 'goober')
#   File.join(Rails.root, 'app/models/goober')
#   "#{Rails.root}/app/models/goober"
#
#   # good
#   Rails.root.join('app/models/goober')
#
# source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#28
class RuboCop::Cop::Rails::FilePath < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#38
  def file_join_nodes?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#50
  def on_dstr(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#59
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#46
  def rails_root_join_nodes?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#42
  def rails_root_nodes?(param0); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#67
  def check_for_file_join_with_rails_root(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#84
  def check_for_rails_root_join_with_slash_separated_path(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#74
  def check_for_rails_root_join_with_string_arguments(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#104
  def message(_range); end

  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#97
  def register_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#93
  def string_with_slash?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#34
RuboCop::Cop::Rails::FilePath::MSG_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#32
RuboCop::Cop::Rails::FilePath::MSG_SLASHES = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/file_path.rb#36
RuboCop::Cop::Rails::FilePath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `where.first` and
# change them to use `find_by` instead.
#
# @example
#   # bad
#   User.where(name: 'Bruce').first
#   User.where(name: 'Bruce').take
#
#   # good
#   User.find_by(name: 'Bruce')
#
# source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#16
class RuboCop::Cop::Rails::FindBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#27
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#27
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#23
  def where_first?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#40
  def autocorrect(corrector, node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#20
RuboCop::Cop::Rails::FindBy::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/find_by.rb#21
RuboCop::Cop::Rails::FindBy::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that `ActiveRecord#find` is used instead of
# `where.take!`, `find_by!`, and `find_by_id!` to retrieve a single record
# by primary key when you expect it to be found.
#
# @example
#   # bad
#   User.where(id: id).take!
#   User.find_by_id!(id)
#   User.find_by!(id: id)
#
#   # good
#   User.find(id)
#
# source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#19
class RuboCop::Cop::Rails::FindById < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#33
  def find_by?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#40
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#26
  def where_take?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#83
  def build_find_by_bad_method(node, id_value); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#75
  def build_good_method(id_value); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#79
  def build_where_take_bad_method(id_value); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#71
  def find_by_offense_range(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#58
  def register_offense(range, id_value, bad_method); end

  # source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#67
  def where_take_offense_range(node, where); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#23
RuboCop::Cop::Rails::FindById::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/find_by_id.rb#24
RuboCop::Cop::Rails::FindById::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `all.each` and
# change them to use `all.find_each` instead.
#
# @example
#   # bad
#   User.all.each
#
#   # good
#   User.all.find_each
# @example IgnoredMethods: ['order']
#   # good
#   User.order(:foo).each
#
# source://rubocop-rails//lib/rubocop/cop/rails/find_each.rb#19
class RuboCop::Cop::Rails::FindEach < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/find_each.rb#30
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/find_each.rb#43
  def ignored?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/find_each.rb#22
RuboCop::Cop::Rails::FindEach::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/find_each.rb#23
RuboCop::Cop::Rails::FindEach::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/find_each.rb#25
RuboCop::Cop::Rails::FindEach::SCOPE_METHODS = T.let(T.unsafe(nil), Array)

# This cop checks for the use of the has_and_belongs_to_many macro.
#
# @example
#   # bad
#   # has_and_belongs_to_many :ingredients
#
#   # good
#   # has_many :ingredients, through: :recipe_ingredients
#
# source://rubocop-rails//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#14
class RuboCop::Cop::Rails::HasAndBelongsToMany < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#18
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#15
RuboCop::Cop::Rails::HasAndBelongsToMany::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/has_and_belongs_to_many.rb#16
RuboCop::Cop::Rails::HasAndBelongsToMany::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for `has_many` or `has_one` associations that don't
# specify a `:dependent` option.
# It doesn't register an offense if `:through` option was specified.
#
# @example
#   # bad
#   class User < ActiveRecord::Base
#   has_many :comments
#   has_one :avatar
#   end
#
#   # good
#   class User < ActiveRecord::Base
#   has_many :comments, dependent: :restrict_with_exception
#   has_one :avatar, dependent: :destroy
#   has_many :patients, through: :appointments
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#23
class RuboCop::Cop::Rails::HasManyOrHasOneDependent < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#27
  def active_resource_class?(param0); end

  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#35
  def association_with_options?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#31
  def association_without_options?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#39
  def dependent_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#54
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#43
  def present_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#47
  def with_options_block(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#95
  def active_resource?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#72
  def contain_valid_options_in_with_options_block?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#86
  def valid_options?(options); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#64
  def valid_options_in_with_options_block?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#24
RuboCop::Cop::Rails::HasManyOrHasOneDependent::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/has_many_or_has_one_dependent.rb#25
RuboCop::Cop::Rails::HasManyOrHasOneDependent::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for use of the helper methods which reference
# instance variables.
#
# Relying on instance variables makes it difficult to re-use helper
# methods.
#
# If it seems awkward to explicitly pass in each dependent
# variable, consider moving the behaviour elsewhere, for
# example to a model, decorator or presenter.
#
# Provided that a class inherits `ActionView::Helpers::FormBuilder`,
# an offense will not be registered.
#
# @example
#   # bad
#   def welcome_message
#   "Hello #{@user.name}"
#   end
#
#   # good
#   def welcome_message(user)
#   "Hello #{user.name}"
#   end
#
#   # good
#   class MyFormBuilder < ActionView::Helpers::FormBuilder
#   @template.do_something
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/helper_instance_variable.rb#34
class RuboCop::Cop::Rails::HelperInstanceVariable < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/helper_instance_variable.rb#37
  def form_builder_class?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/helper_instance_variable.rb#43
  def on_ivar(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/helper_instance_variable.rb#49
  def on_ivasgn(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/helper_instance_variable.rb#57
  def inherit_form_builder?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/helper_instance_variable.rb#35
RuboCop::Cop::Rails::HelperInstanceVariable::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of http methods like `get`, `post`,
# `put`, `patch` without the usage of keyword arguments in your tests and
# change them to use keyword args. This cop only applies to Rails >= 5.
# If you are running Rails < 5 you should disable the
# Rails/HttpPositionalArguments cop or set your TargetRailsVersion in your
# .rubocop.yml file to 4.2.
#
# @example
#   # bad
#   get :new, { user_id: 1}
#
#   # good
#   get :new, params: { user_id: 1 }
#   get :new, **options
#
# source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#20
class RuboCop::Cop::Rails::HttpPositionalArguments < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#33
  def http_request?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#37
  def kwsplat_hash?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#41
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#83
  def convert_hash_data(data, type); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#98
  def correction(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#111
  def correction_template(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#79
  def format_arg?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#65
  def needs_conversion?(data); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#75
  def special_keyword_arg?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#26
RuboCop::Cop::Rails::HttpPositionalArguments::KEYWORD_ARGS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#24
RuboCop::Cop::Rails::HttpPositionalArguments::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/http_positional_arguments.rb#29
RuboCop::Cop::Rails::HttpPositionalArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Enforces use of symbolic or numeric value to define HTTP status.
#
# @example EnforcedStyle: symbolic (default)
#   # bad
#   render :foo, status: 200
#   render json: { foo: 'bar' }, status: 200
#   render plain: 'foo/bar', status: 304
#   redirect_to root_url, status: 301
#
#   # good
#   render :foo, status: :ok
#   render json: { foo: 'bar' }, status: :ok
#   render plain: 'foo/bar', status: :not_modified
#   redirect_to root_url, status: :moved_permanently
# @example EnforcedStyle: numeric
#   # bad
#   render :foo, status: :ok
#   render json: { foo: 'bar' }, status: :not_found
#   render plain: 'foo/bar', status: :not_modified
#   redirect_to root_url, status: :moved_permanently
#
#   # good
#   render :foo, status: 200
#   render json: { foo: 'bar' }, status: 404
#   render plain: 'foo/bar', status: 304
#   redirect_to root_url, status: 301
#
# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#34
class RuboCop::Cop::Rails::HttpStatus < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#40
  def http_status(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#51
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#47
  def status_code(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#67
  def checker_class; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#118
class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  # @return [NumericStyleChecker] a new instance of NumericStyleChecker
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#127
  def initialize(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#135
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#125
  def node; end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#131
  def offensive?; end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#139
  def preferred_style; end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#145
  def number; end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#153
  def permitted_symbol?; end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#149
  def symbol; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#121
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#119
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#123
RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker::PERMITTED_STATUS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#38
RuboCop::Cop::Rails::HttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#77
class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  # @return [SymbolicStyleChecker] a new instance of SymbolicStyleChecker
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#85
  def initialize(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#93
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#83
  def node; end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#89
  def offensive?; end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#97
  def preferred_style; end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#111
  def custom_http_status_code?; end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#107
  def number; end

  # source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#103
  def symbol; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#80
RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::DEFAULT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/http_status.rb#78
RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker::MSG = T.let(T.unsafe(nil), String)

# This cop checks that `if` and `only` (or `except`) are not used together
# as options of `skip_*` action filter.
#
# The `if` option will be ignored when `if` and `only` are used together.
# Similarly, the `except` option will be ignored when `if` and `except`
# are used together.
#
# @example
#   # bad
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   only: :show, if: :trusted_origin?
#   end
#
#   # good
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   if: -> { trusted_origin? && action_name == "show" }
#   end
# @example
#   # bad
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   except: :admin, if: :trusted_origin?
#   end
#
#   # good
#   class MyPageController < ApplicationController
#   skip_before_action :login_required,
#   if: -> { trusted_origin? && action_name != "admin" }
#   end
# @see https://api.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-_normalize_callback_options
#
# source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#40
class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#54
  def filter_options(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#62
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#90
  def if_and_except?(options); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#86
  def if_and_only?(options); end

  # source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#80
  def options_hash(options); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#52
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::FILTERS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#41
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/ignored_skip_action_filter_option.rb#45
RuboCop::Cop::Rails::IgnoredSkipActionFilterOption::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for uses of `each_with_object({}) { ... }`,
# `map { ... }.to_h`, and `Hash[map { ... }]` that are transforming
# an enumerable into a hash where the values are the original elements.
# Rails provides the `index_by` method for this purpose.
#
# @example
#   # bad
#   [1, 2, 3].each_with_object({}) { |el, h| h[foo(el)] = el }
#   [1, 2, 3].to_h { |el| [foo(el), el] }
#   [1, 2, 3].map { |el| [foo(el), el] }.to_h
#   Hash[[1, 2, 3].collect { |el| [foo(el), el] }]
#
#   # good
#   [1, 2, 3].index_by { |el| foo(el) }
#
# source://rubocop-rails//lib/rubocop/cop/rails/index_by.rb#20
class RuboCop::Cop::Rails::IndexBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IndexMethod
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/index_by.rb#24
  def on_bad_each_with_object(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/index_by.rb#47
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/index_by.rb#38
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/index_by.rb#31
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/index_by.rb#59
  def new_method_name; end
end

# This cop looks for uses of `each_with_object({}) { ... }`,
# `map { ... }.to_h`, and `Hash[map { ... }]` that are transforming
# an enumerable into a hash where the keys are the original elements.
# Rails provides the `index_with` method for this purpose.
#
# @example
#   # bad
#   [1, 2, 3].each_with_object({}) { |el, h| h[el] = foo(el) }
#   [1, 2, 3].to_h { |el| [el, foo(el)] }
#   [1, 2, 3].map { |el| [el, foo(el)] }.to_h
#   Hash[[1, 2, 3].collect { |el| [el, foo(el)] }]
#
#   # good
#   [1, 2, 3].index_with { |el| foo(el) }
#
# source://rubocop-rails//lib/rubocop/cop/rails/index_with.rb#20
class RuboCop::Cop::Rails::IndexWith < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IndexMethod
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/index_with.rb#27
  def on_bad_each_with_object(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/index_with.rb#50
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/index_with.rb#41
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/index_with.rb#34
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/index_with.rb#62
  def new_method_name; end
end

# This cop checks that Active Support's `inquiry` method is not used.
#
# @example
#   # bad - String#inquiry
#   ruby = 'two'.inquiry
#   ruby.two?
#
#   # good
#   ruby = 'two'
#   ruby == 'two'
#
#   # bad - Array#inquiry
#   pets = %w(cat dog).inquiry
#   pets.gopher?
#
#   # good
#   pets = %w(cat dog)
#   pets.include? 'cat'
#
# source://rubocop-rails//lib/rubocop/cop/rails/inquiry.rb#25
class RuboCop::Cop::Rails::Inquiry < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/inquiry.rb#29
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/inquiry.rb#26
RuboCop::Cop::Rails::Inquiry::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/inquiry.rb#27
RuboCop::Cop::Rails::Inquiry::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop looks for has_(one|many) and belongs_to associations where
# Active Record can't automatically determine the inverse association
# because of a scope or the options used. Using the blog with order scope
# example below, traversing the a Blog's association in both directions
# with `blog.posts.first.blog` would cause the `blog` to be loaded from
# the database twice.
#
# `:inverse_of` must be manually specified for Active Record to use the
# associated object in memory, or set to `false` to opt-out. Note that
# setting `nil` does not stop Active Record from trying to determine the
# inverse automatically, and is not considered a valid value for this.
#
# @example
#   # good
#   class Blog < ApplicationRecord
#   has_many :posts
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
# @example
#   # bad
#   class Blog < ApplicationRecord
#   has_many :posts, -> { order(published_at: :desc) }
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   class Blog < ApplicationRecord
#   has_many(:posts,
#   -> { order(published_at: :desc) },
#   inverse_of: :blog)
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   class Blog < ApplicationRecord
#   with_options inverse_of: :blog do
#   has_many :posts, -> { order(published_at: :desc) }
#   end
#   end
#
#   class Post < ApplicationRecord
#   belongs_to :blog
#   end
#
#   # good
#   # When you don't want to use the inverse association.
#   class Blog < ApplicationRecord
#   has_many(:posts,
#   -> { order(published_at: :desc) },
#   inverse_of: false)
#   end
# @example
#   # bad
#   class Picture < ApplicationRecord
#   belongs_to :imageable, polymorphic: true
#   end
#
#   class Employee < ApplicationRecord
#   has_many :pictures, as: :imageable
#   end
#
#   class Product < ApplicationRecord
#   has_many :pictures, as: :imageable
#   end
#
#   # good
#   class Picture < ApplicationRecord
#   belongs_to :imageable, polymorphic: true
#   end
#
#   class Employee < ApplicationRecord
#   has_many :pictures, as: :imageable, inverse_of: :imageable
#   end
#
#   class Product < ApplicationRecord
#   has_many :pictures, as: :imageable, inverse_of: :imageable
#   end
# @example
#   # bad
#   # However, RuboCop can not detect this pattern...
#   class Physician < ApplicationRecord
#   has_many :appointments
#   has_many :patients, through: :appointments
#   end
#
#   class Appointment < ApplicationRecord
#   belongs_to :physician
#   belongs_to :patient
#   end
#
#   class Patient < ApplicationRecord
#   has_many :appointments
#   has_many :physicians, through: :appointments
#   end
#
#   # good
#   class Physician < ApplicationRecord
#   has_many :appointments
#   has_many :patients, through: :appointments
#   end
#
#   class Appointment < ApplicationRecord
#   belongs_to :physician, inverse_of: :appointments
#   belongs_to :patient, inverse_of: :appointments
#   end
#
#   class Patient < ApplicationRecord
#   has_many :appointments
#   has_many :physicians, through: :appointments
#   end
# @see https://guides.rubyonrails.org/association_basics.html#bi-directional-associations
# @see https://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#module-ActiveRecord::Associations::ClassMethods-label-Setting+Inverses
#
# source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#131
class RuboCop::Cop::Rails::InverseOf < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#157
  def as_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#137
  def association_recv_arguments(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#145
  def conditions_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#161
  def foreign_key_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#169
  def inverse_of_nil_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#165
  def inverse_of_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#173
  def on_send(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#213
  def options_contain_inverse_of?(options); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#141
  def options_from_argument(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#207
  def options_ignoring_inverse_of?(options); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#196
  def options_requiring_inverse_of?(options); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#153
  def polymorphic_option?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#225
  def same_context_in_with_options?(arg, recv); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#192
  def scope?(arguments); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#149
  def through_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#217
  def with_options_arguments(recv, node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#233
  def message(options); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#133
RuboCop::Cop::Rails::InverseOf::NIL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#135
RuboCop::Cop::Rails::InverseOf::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/inverse_of.rb#132
RuboCop::Cop::Rails::InverseOf::SPECIFY_MSG = T.let(T.unsafe(nil), String)

# This cop checks that methods specified in the filter's `only` or
# `except` options are defined within the same class or module.
#
# You can technically specify methods of superclass or methods added by
# mixins on the filter, but these can confuse developers. If you specify
# methods that are defined in other classes or modules, you should
# define the filter in that class or module.
#
# If you rely on behaviour defined in the superclass actions, you must
# remember to invoke `super` in the subclass actions.
#
# @example
#   # bad
#   class LoginController < ApplicationController
#   before_action :require_login, only: %i[index settings logout]
#
#   def index
#   end
#   end
#
#   # good
#   class LoginController < ApplicationController
#   before_action :require_login, only: %i[index settings logout]
#
#   def index
#   end
#
#   def settings
#   end
#
#   def logout
#   end
#   end
# @example
#   # bad
#   module FooMixin
#   extend ActiveSupport::Concern
#
#   included do
#   before_action proc { authenticate }, only: :foo
#   end
#   end
#
#   # good
#   module FooMixin
#   extend ActiveSupport::Concern
#
#   included do
#   before_action proc { authenticate }, only: :foo
#   end
#
#   def foo
#   # something
#   end
#   end
# @example
#   class ContentController < ApplicationController
#   def update
#   @content.update(content_attributes)
#   end
#   end
#
#   class ArticlesController < ContentController
#   before_action :load_article, only: [:update]
#
#   # the cop requires this method, but it relies on behaviour defined
#   # in the superclass, so needs to invoke `super`
#   def update
#   super
#   end
#
#   private
#
#   def load_article
#   @content = Article.find(params[:article_id])
#   end
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#85
class RuboCop::Cop::Rails::LexicallyScopedActionFilter < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#117
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#106
  def only_or_except_filter_methods(param0 = T.unsafe(nil)); end

  private

  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#140
  def array_values(node); end

  # @param methods [Array<String>]
  # @param parent [RuboCop::AST::Node]
  # @return [String]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#163
  def message(methods, parent); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#104
RuboCop::Cop::Rails::LexicallyScopedActionFilter::FILTERS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#86
RuboCop::Cop::Rails::LexicallyScopedActionFilter::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/lexically_scoped_action_filter.rb#88
RuboCop::Cop::Rails::LexicallyScopedActionFilter::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for calls to `link_to` that contain a
# `target: '_blank'` but no `rel: 'noopener'`. This can be a security
# risk as the loaded page will have control over the previous page
# and could change its location for phishing purposes.
#
# The option `rel: 'noreferrer'` also blocks this behavior
# and removes the http-referrer header.
#
# @example
#   # bad
#   link_to 'Click here', url, target: '_blank'
#
#   # good
#   link_to 'Click here', url, target: '_blank', rel: 'noopener'
#
#   # good
#   link_to 'Click here', url, target: '_blank', rel: 'noreferrer'
#
# source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#23
class RuboCop::Cop::Rails::LinkToBlank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#29
  def blank_target?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#33
  def includes_noopener?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#41
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#37
  def rel_node?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#78
  def add_rel(send_node, offence_node, corrector); end

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#69
  def append_to_rel(rel_node, corrector); end

  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#56
  def autocorrect(corrector, send_node, node, option_nodes); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#87
  def contains_noopener?(value); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#26
RuboCop::Cop::Rails::LinkToBlank::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/link_to_blank.rb#27
RuboCop::Cop::Rails::LinkToBlank::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that mailer names end with `Mailer` suffix.
#
# Without the `Mailer` suffix it isn't immediately apparent what's a mailer
# and which views are related to the mailer.
#
# @example
#   # bad
#   class User < ActionMailer::Base
#   end
#
#   class User < ApplicationMailer
#   end
#
#   # good
#   class UserMailer < ActionMailer::Base
#   end
#
#   class UserMailer < ApplicationMailer
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#26
class RuboCop::Cop::Rails::MailerName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#38
  def class_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#42
  def class_new_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#31
  def mailer_base_class?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#46
  def on_class(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#54
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#70
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#80
  def mailer_suffix?(mailer_name); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/mailer_name.rb#29
RuboCop::Cop::Rails::MailerName::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where defining routes with `match`
# can be replaced with a specific HTTP method.
#
# Don't use `match` to define any routes unless there is a need to map multiple request types
# among [:get, :post, :patch, :put, :delete] to a single action using the `:via` option.
#
# @example
#   # bad
#   match ':controller/:action/:id'
#   match 'photos/:id', to: 'photos#show', via: :get
#
#   # good
#   get ':controller/:action/:id'
#   get 'photos/:id', to: 'photos#show'
#   match 'photos/:id', to: 'photos#show', via: [:get, :post]
#   match 'photos/:id', to: 'photos#show', via: :all
#
# source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#23
class RuboCop::Cop::Rails::MatchRoute < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#30
  def match_method_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#34
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#63
  def routes_draw?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#71
  def extract_via(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#90
  def http_method?(method); end

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#111
  def http_method_and_options(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#53
  def register_offense(node, http_method); end

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#94
  def replacement(path_node, options_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#86
  def via_pair(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#67
  def within_routes?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#28
RuboCop::Cop::Rails::MatchRoute::HTTP_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#26
RuboCop::Cop::Rails::MatchRoute::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/match_route.rb#27
RuboCop::Cop::Rails::MatchRoute::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces the use of `collection.exclude?(obj)`
# over `!collection.include?(obj)`.
#
# It is marked as unsafe by default because false positive will occur for
# a receiver object that do not have `exclude?` method. (e.g. `IPAddr`)
#
# @example
#   # bad
#   !array.include?(2)
#   !hash.include?(:key)
#
#   # good
#   array.exclude?(2)
#   hash.exclude?(:key)
#
# source://rubocop-rails//lib/rubocop/cop/rails/negate_include.rb#21
class RuboCop::Cop::Rails::NegateInclude < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/negate_include.rb#27
  def negate_include_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/negate_include.rb#31
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/negate_include.rb#24
RuboCop::Cop::Rails::NegateInclude::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/negate_include.rb#25
RuboCop::Cop::Rails::NegateInclude::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for add_column call with NOT NULL constraint
# in migration file.
#
# @example
#   # bad
#   add_column :users, :name, :string, null: false
#   add_reference :products, :category, null: false
#
#   # good
#   add_column :users, :name, :string, null: true
#   add_column :users, :name, :string, null: false, default: ''
#   add_reference :products, :category
#   add_reference :products, :category, null: false, default: 1
#
# source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#19
class RuboCop::Cop::Rails::NotNullColumn < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#23
  def add_not_null_column?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#27
  def add_not_null_reference?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#35
  def default_option?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#31
  def null_false?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#39
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#46
  def check_add_column(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#51
  def check_add_reference(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#56
  def check_pairs(pairs); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#20
RuboCop::Cop::Rails::NotNullColumn::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/not_null_column.rb#21
RuboCop::Cop::Rails::NotNullColumn::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for places where ordering by `id` column is used.
#
# Don't use the `id` column for ordering. The sequence of ids is not guaranteed
# to be in any particular order, despite often (incidentally) being chronological.
# Use a timestamp column to order chronologically. As a bonus the intent is clearer.
#
# NOTE: Make sure the changed order column does not introduce performance
# bottlenecks and appropriate database indexes are added.
#
# @example
#   # bad
#   scope :chronological, -> { order(id: :asc) }
#   scope :chronological, -> { order(primary_key => :asc) }
#
#   # good
#   scope :chronological, -> { order(created_at: :asc) }
#
# source://rubocop-rails//lib/rubocop/cop/rails/order_by_id.rb#23
class RuboCop::Cop::Rails::OrderById < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-rails//lib/rubocop/cop/rails/order_by_id.rb#40
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/order_by_id.rb#30
  def order_by_id?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/order_by_id.rb#46
  def offense_range(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/order_by_id.rb#26
RuboCop::Cop::Rails::OrderById::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/order_by_id.rb#28
RuboCop::Cop::Rails::OrderById::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of output calls like puts and print
#
# @example
#   # bad
#   puts 'A debug message'
#   pp 'A debug message'
#   print 'A debug message'
#
#   # good
#   Rails.logger.debug 'A debug message'
#
# source://rubocop-rails//lib/rubocop/cop/rails/output.rb#16
class RuboCop::Cop::Rails::Output < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/output.rb#27
  def io_output?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/output.rb#37
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/output.rb#23
  def output?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/output.rb#46
  def match_gvar?(sym); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/output.rb#17
RuboCop::Cop::Rails::Output::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/output.rb#19
RuboCop::Cop::Rails::Output::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of output safety calls like `html_safe`,
# `raw`, and `safe_concat`. These methods do not escape content. They
# simply return a SafeBuffer containing the content as is. Instead,
# use `safe_join` to join content and escape it and concat to
# concatenate content and escape it, ensuring its safety.
#
# @example
#   user_content = "<b>hi</b>"
#
#   # bad
#   "<p>#{user_content}</p>".html_safe
#   # => ActiveSupport::SafeBuffer "<p><b>hi</b></p>"
#
#   # good
#   content_tag(:p, user_content)
#   # => ActiveSupport::SafeBuffer "<p>&lt;b&gt;hi&lt;/b&gt;</p>"
#
#   # bad
#   out = ""
#   out << "<li>#{user_content}</li>"
#   out << "<li>#{user_content}</li>"
#   out.html_safe
#   # => ActiveSupport::SafeBuffer "<li><b>hi</b></li><li><b>hi</b></li>"
#
#   # good
#   out = []
#   out << content_tag(:li, user_content)
#   out << content_tag(:li, user_content)
#   safe_join(out)
#   # => ActiveSupport::SafeBuffer
#   #    "<li>&lt;b&gt;hi&lt;/b&gt;</li><li>&lt;b&gt;hi&lt;/b&gt;</li>"
#
#   # bad
#   out = "<h1>trusted content</h1>".html_safe
#   out.safe_concat(user_content)
#   # => ActiveSupport::SafeBuffer "<h1>trusted_content</h1><b>hi</b>"
#
#   # good
#   out = "<h1>trusted content</h1>".html_safe
#   out.concat(user_content)
#   # => ActiveSupport::SafeBuffer
#   #    "<h1>trusted_content</h1>&lt;b&gt;hi&lt;/b&gt;"
#
#   # safe, though maybe not good style
#   out = "trusted content"
#   result = out.concat(user_content)
#   # => String "trusted content<b>hi</b>"
#   # because when rendered in ERB the String will be escaped:
#   # <%= result %>
#   # => trusted content&lt;b&gt;hi&lt;/b&gt;
#
#   # bad
#   (user_content + " " + content_tag(:span, user_content)).html_safe
#   # => ActiveSupport::SafeBuffer "<b>hi</b> <span><b>hi</b></span>"
#
#   # good
#   safe_join([user_content, " ", content_tag(:span, user_content)])
#   # => ActiveSupport::SafeBuffer
#   #    "&lt;b&gt;hi&lt;/b&gt; <span>&lt;b&gt;hi&lt;/b&gt;</span>"
#
# source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#65
class RuboCop::Cop::Rails::OutputSafety < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#69
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#69
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#86
  def looks_like_rails_html_safe?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#90
  def looks_like_rails_raw?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#94
  def looks_like_rails_safe_concat?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#82
  def non_interpolated_string?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#66
RuboCop::Cop::Rails::OutputSafety::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/output_safety.rb#67
RuboCop::Cop::Rails::OutputSafety::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces the use of `pick` over `pluck(...).first`.
#
# Using `pluck` followed by `first` creates an intermediate array, which
# `pick` avoids. When called on an Active Record relation, `pick` adds a
# limit to the query so that only one value is fetched from the database.
#
# @example
#   # bad
#   Model.pluck(:a).first
#   [{ a: :b, c: :d }].pluck(:a, :b).first
#
#   # good
#   Model.pick(:a)
#   [{ a: :b, c: :d }].pick(:a, :b)
#
# source://rubocop-rails//lib/rubocop/cop/rails/pick.rb#20
class RuboCop::Cop::Rails::Pick < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/pick.rb#33
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pick.rb#29
  def pick_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/pick.rb#51
  def message(receiver); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/pick.rb#24
RuboCop::Cop::Rails::Pick::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/pick.rb#25
RuboCop::Cop::Rails::Pick::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces the use of `pluck` over `map`.
#
# `pluck` can be used instead of `map` to extract a single key from each
# element in an enumerable. When called on an Active Record relation, it
# results in a more efficient query that only selects the necessary key.
#
# @example
#   # bad
#   Post.published.map { |post| post[:title] }
#   [{ a: :b, c: :d }].collect { |el| el[:a] }
#
#   # good
#   Post.published.pluck(:title)
#   [{ a: :b, c: :d }].pluck(:a)
#
# source://rubocop-rails//lib/rubocop/cop/rails/pluck.rb#20
class RuboCop::Cop::Rails::Pluck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRailsVersion

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck.rb#32
  def on_block(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck.rb#28
  def pluck_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck.rb#50
  def message(method, argument, element, value); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck.rb#46
  def offense_range(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/pluck.rb#24
RuboCop::Cop::Rails::Pluck::MSG = T.let(T.unsafe(nil), String)

# This cop enforces the use of `ids` over `pluck(:id)` and `pluck(primary_key)`.
#
# @example
#   # bad
#   User.pluck(:id)
#   user.posts.pluck(:id)
#
#   def self.user_ids
#   pluck(primary_key)
#   end
#
#   # good
#   User.ids
#   user.posts.ids
#
#   def self.user_ids
#   ids
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/pluck_id.rb#25
class RuboCop::Cop::Rails::PluckId < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ActiveRecordHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck_id.rb#37
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck_id.rb#33
  def pluck_id_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck_id.rb#50
  def offense_range(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/pluck_id.rb#30
RuboCop::Cop::Rails::PluckId::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/pluck_id.rb#31
RuboCop::Cop::Rails::PluckId::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `pluck` is used in `where` query methods
# and can be replaced with `select`.
#
# Since `pluck` is an eager method and hits the database immediately,
# using `select` helps to avoid additional database queries.
#
# This cop has two different enforcement modes. When the EnforcedStyle
# is conservative (the default) then only calls to `pluck` on a constant
# (i.e. a model class) in the `where` is used as offenses.
#
# When the EnforcedStyle is aggressive then all calls to `pluck` in the
# `where` is used as offenses. This may lead to false positives
# as the cop cannot replace to `select` between calls to `pluck` on an
# `ActiveRecord::Relation` instance vs a call to `pluck` on an `Array` instance.
#
# @example
#   # bad
#   Post.where(user_id: User.active.pluck(:id))
#
#   # good
#   Post.where(user_id: User.active.select(:id))
#   Post.where(user_id: active_users.select(:id))
# @example EnforcedStyle: conservative (default)
#   # good
#   Post.where(user_id: active_users.pluck(:id))
# @example EnforcedStyle: aggressive
#   # bad
#   Post.where(user_id: active_users.pluck(:id))
#
# source://rubocop-rails//lib/rubocop/cop/rails/pluck_in_where.rb#37
class RuboCop::Cop::Rails::PluckInWhere < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck_in_where.rb#45
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/pluck_in_where.rb#58
  def root_receiver(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/pluck_in_where.rb#42
RuboCop::Cop::Rails::PluckInWhere::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/pluck_in_where.rb#43
RuboCop::Cop::Rails::PluckInWhere::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for correct grammar when using ActiveSupport's
# core extensions to the numeric classes.
#
# @example
#   # bad
#   3.day.ago
#   1.months.ago
#
#   # good
#   3.days.ago
#   1.month.ago
#
# source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#17
class RuboCop::Cop::Rails::PluralizationGrammar < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#35
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#53
  def correct_method(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#96
  def duration_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#84
  def literal_number?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#49
  def message(number, method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#61
  def offense?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#68
  def plural_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#80
  def plural_receiver?(number); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#88
  def pluralize(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#72
  def singular_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#76
  def singular_receiver?(number); end

  # source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#92
  def singularize(method_name); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#33
RuboCop::Cop::Rails::PluralizationGrammar::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#31
RuboCop::Cop::Rails::PluralizationGrammar::PLURAL_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#29
RuboCop::Cop::Rails::PluralizationGrammar::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/pluralization_grammar.rb#20
RuboCop::Cop::Rails::PluralizationGrammar::SINGULAR_DURATION_METHODS = T.let(T.unsafe(nil), Hash)

# This cop checks code that can be written more easily using
# `Object#presence` defined by Active Support.
#
# @example
#   # bad
#   a.present? ? a : nil
#
#   # bad
#   !a.present? ? nil : a
#
#   # bad
#   a.blank? ? nil : a
#
#   # bad
#   !a.blank? ? a : nil
#
#   # good
#   a.presence
# @example
#   # bad
#   a.present? ? a : b
#
#   # bad
#   !a.present? ? b : a
#
#   # bad
#   a.blank? ? b : a
#
#   # bad
#   !a.blank? ? a : b
#
#   # good
#   a.presence || b
#
# source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#40
class RuboCop::Cop::Rails::Presence < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#76
  def on_if(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#61
  def redundant_negative_receiver_and_other(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#46
  def redundant_receiver_and_other(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#126
  def build_source_for_or_method(other); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#100
  def ignore_if_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#104
  def ignore_other_node?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#108
  def message(node, receiver, other); end

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#94
  def register_offense(node, receiver, other); end

  # source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#114
  def replacement(receiver, other); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/presence.rb#44
RuboCop::Cop::Rails::Presence::MSG = T.let(T.unsafe(nil), String)

# This cop checks for code that can be written with simpler conditionals
# using `Object#present?` defined by Active Support.
#
# Interaction with `Style/UnlessElse`:
# The configuration of `NotBlank` will not produce an offense in the
# context of `unless else` if `Style/UnlessElse` is inabled. This is
# to prevent interference between the auto-correction of the two cops.
#
# @example NotNilAndNotEmpty: true (default)
#   # Converts usages of `!nil? && !empty?` to `present?`
#
#   # bad
#   !foo.nil? && !foo.empty?
#
#   # bad
#   foo != nil && !foo.empty?
#
#   # good
#   foo.present?
# @example NotBlank: true (default)
#   # Converts usages of `!blank?` to `present?`
#
#   # bad
#   !foo.blank?
#
#   # bad
#   not foo.blank?
#
#   # good
#   foo.present?
# @example UnlessBlank: true (default)
#   # Converts usages of `unless blank?` to `if present?`
#
#   # bad
#   something unless foo.blank?
#
#   # good
#   something if foo.present?
#
# source://rubocop-rails//lib/rubocop/cop/rails/present.rb#46
class RuboCop::Cop::Rails::Present < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#129
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#56
  def exists_and_not_empty?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#70
  def not_blank?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#88
  def on_and(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#114
  def on_if(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#102
  def on_or(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#76
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#72
  def unless_blank?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#153
  def replacement(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/present.rb#145
  def unless_condition(node, method_call); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/present.rb#50
RuboCop::Cop::Rails::Present::MSG_EXISTS_AND_NOT_EMPTY = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/present.rb#49
RuboCop::Cop::Rails::Present::MSG_NOT_BLANK = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/present.rb#52
RuboCop::Cop::Rails::Present::MSG_UNLESS_BLANK = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/present.rb#54
RuboCop::Cop::Rails::Present::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for Rake tasks without the `:environment` task
# dependency. The `:environment` task loads application code for other
# Rake tasks. Without it, tasks cannot make use of application code like
# models.
#
# You can ignore the offense if the task satisfies at least one of the
# following conditions:
#
# * The task does not need application code.
# * The task invokes the `:environment` task.
#
# @example
#   # bad
#   task :foo do
#   do_something
#   end
#
#   # good
#   task foo: :environment do
#   do_something
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#28
class RuboCop::Cop::Rails::RakeEnvironment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#37
  def on_block(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#33
  def task_definition?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#53
  def correct_task_dependency(task_name); end

  # source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#61
  def task_name(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#78
  def with_dependencies?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#93
  def with_hash_style_dependencies?(hash_node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/rake_environment.rb#31
RuboCop::Cop::Rails::RakeEnvironment::MSG = T.let(T.unsafe(nil), String)

# This cop checks for the use of the `read_attribute` or `write_attribute`
# methods and recommends square brackets instead.
#
# If an attribute is missing from the instance (for example, when
# initialized by a partial `select`) then `read_attribute`
# will return nil, but square brackets will raise
# an `ActiveModel::MissingAttributeError`.
#
# Explicitly raising an error in this situation is preferable, and that
# is why rubocop recommends using square brackets.
#
# @example
#
#   # bad
#   x = read_attribute(:attr)
#   write_attribute(:attr, val)
#
#   # good
#   x = self[:attr]
#   self[:attr] = val
#
# source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#26
class RuboCop::Cop::Rails::ReadWriteAttribute < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#39
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#32
  def read_write_attribute?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#56
  def message(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#65
  def read_attribute_replacement(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#69
  def write_attribute_replacement(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#29
RuboCop::Cop::Rails::ReadWriteAttribute::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/read_write_attribute.rb#30
RuboCop::Cop::Rails::ReadWriteAttribute::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks Rails model validations for a redundant `allow_nil` when
# `allow_blank` is present.
#
# @example
#   # bad
#   validates :x, length: { is: 5 }, allow_nil: true, allow_blank: true
#
#   # bad
#   validates :x, length: { is: 5 }, allow_nil: false, allow_blank: true
#
#   # bad
#   validates :x, length: { is: 5 }, allow_nil: false, allow_blank: false
#
#   # good
#   validates :x, length: { is: 5 }, allow_blank: true
#
#   # good
#   validates :x, length: { is: 5 }, allow_blank: false
#
#   # good
#   # Here, `nil` is valid but `''` is not
#   validates :x, length: { is: 5 }, allow_nil: true, allow_blank: false
#
# source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#29
class RuboCop::Cop::Rails::RedundantAllowNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#41
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#72
  def find_allow_nil_and_allow_blank(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#95
  def next_sibling(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#99
  def node_beg(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#103
  def node_end(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#91
  def previous_sibling(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#57
  def register_offense(allow_nil, message); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#36
RuboCop::Cop::Rails::RedundantAllowNil::MSG_ALLOW_NIL_FALSE = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#33
RuboCop::Cop::Rails::RedundantAllowNil::MSG_SAME = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/redundant_allow_nil.rb#39
RuboCop::Cop::Rails::RedundantAllowNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop detects cases where the `:foreign_key` option on associations
# is redundant.
#
# @example
#   # bad
#   class Post
#   has_many :comments, foreign_key: 'post_id'
#   end
#
#   class Comment
#   belongs_to :post, foreign_key: 'post_id'
#   end
#
#   # good
#   class Post
#   has_many :comments
#   end
#
#   class Comment
#   belongs_to :author, foreign_key: 'user_id'
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#27
class RuboCop::Cop::Rails::RedundantForeignKey < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#34
  def association_with_foreign_key(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#40
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#59
  def default_foreign_key(node, association_type, association_name, options); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#69
  def find_as_option(options); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#55
  def redundant?(node, association_type, association_name, options, foreign_key); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#31
RuboCop::Cop::Rails::RedundantForeignKey::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/redundant_foreign_key.rb#32
RuboCop::Cop::Rails::RedundantForeignKey::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for redundant receiver in `with_options`.
# Receiver is implicit from Rails 4.2 or higher.
#
# @example
#   # bad
#   class Account < ApplicationRecord
#   with_options dependent: :destroy do |assoc|
#   assoc.has_many :customers
#   assoc.has_many :products
#   assoc.has_many :invoices
#   assoc.has_many :expenses
#   end
#   end
#
#   # good
#   class Account < ApplicationRecord
#   with_options dependent: :destroy do
#   has_many :customers
#   has_many :products
#   has_many :invoices
#   has_many :expenses
#   end
#   end
# @example
#   # bad
#   with_options options: false do |merger|
#   merger.invoke(merger.something)
#   end
#
#   # good
#   with_options options: false do
#   invoke(something)
#   end
#
#   # good
#   client = Client.new
#   with_options options: false do |merger|
#   client.invoke(merger.something, something)
#   end
#
#   # ok
#   # When `with_options` includes a block, all scoping scenarios
#   # cannot be evaluated. Thus, it is ok to include the explicit
#   # receiver.
#   with_options options: false do |merger|
#   merger.invoke
#   with_another_method do |another_receiver|
#   merger.invoke(another_receiver)
#   end
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#57
class RuboCop::Cop::Rails::RedundantReceiverInWithOptions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#72
  def all_block_nodes_in(param0); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#76
  def all_send_nodes_in(param0); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#80
  def on_block(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#63
  def with_options?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#100
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#106
  def block_argument_range(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#128
  def same_value?(arg_node, recv_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#118
  def search_begin_pos_of_space_before_block_argument(begin_pos); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/redundant_receiver_in_with_options.rb#61
RuboCop::Cop::Rails::RedundantReceiverInWithOptions::MSG = T.let(T.unsafe(nil), String)

# This cop checks if the value of the option `class_name`, in
# the definition of a reflection is a string.
#
# @example
#   # bad
#   has_many :accounts, class_name: Account
#   has_many :accounts, class_name: Account.name
#
#   # good
#   has_many :accounts, class_name: 'Account'
#
# source://rubocop-rails//lib/rubocop/cop/rails/reflection_class_name.rb#16
class RuboCop::Cop::Rails::ReflectionClassName < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/reflection_class_name.rb#20
  def association_with_reflection(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reflection_class_name.rb#30
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reflection_class_name.rb#26
  def reflection_class_name(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/reflection_class_name.rb#17
RuboCop::Cop::Rails::ReflectionClassName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/reflection_class_name.rb#18
RuboCop::Cop::Rails::ReflectionClassName::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use `assert_not` methods instead of `refute` methods.
#
# @example EnforcedStyle: assert_not (default)
#   # bad
#   refute false
#   refute_empty [1, 2, 3]
#   refute_equal true, false
#
#   # good
#   assert_not false
#   assert_not_empty [1, 2, 3]
#   assert_not_equal true, false
# @example EnforcedStyle: refute
#   # bad
#   assert_not false
#   assert_not_empty [1, 2, 3]
#   assert_not_equal true, false
#
#   # good
#   refute false
#   refute_empty [1, 2, 3]
#   refute_equal true, false
#
# source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#31
class RuboCop::Cop::Rails::RefuteMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#59
  def offensive?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#61
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#75
  def bad_method?(method_name); end

  # source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#91
  def convert_good_method(bad_method); end

  # source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#83
  def offense_message(method_name); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#55
RuboCop::Cop::Rails::RefuteMethods::ASSERT_NOT_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#37
RuboCop::Cop::Rails::RefuteMethods::CORRECTIONS = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#35
RuboCop::Cop::Rails::RefuteMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#54
RuboCop::Cop::Rails::RefuteMethods::REFUTE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/refute_methods.rb#57
RuboCop::Cop::Rails::RefuteMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks whether constant value isn't relative date.
# Because the relative date will be evaluated only once.
#
# @example
#   # bad
#   class SomeClass
#   EXPIRED_AT = 1.week.since
#   end
#
#   # good
#   class SomeClass
#   EXPIRES = 1.week
#
#   def self.expired_at
#   EXPIRES.since
#   end
#   end
#
#   # good
#   class SomeClass
#   def self.expired_at
#   1.week.since
#   end
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#30
class RuboCop::Cop::Rails::RelativeDateConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#37
  def on_casgn(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#45
  def on_masgn(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#61
  def on_or_asgn(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#103
  def relative_date?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#91
  def relative_date_assignment?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#99
  def relative_date_or_assignment?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#69
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#83
  def message(method_name); end

  # source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#87
  def offense_range(name, value); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/relative_date_constant.rb#34
RuboCop::Cop::Rails::RelativeDateConstant::MSG = T.let(T.unsafe(nil), String)

# This cop looks for inline rendering within controller actions.
#
# @example
#   # bad
#   class ProductsController < ApplicationController
#   def index
#   render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>", type: :erb
#   end
#   end
#
#   # good
#   # app/views/products/index.html.erb
#   # <% products.each do |p| %>
#   #   <p><%= p.name %></p>
#   # <% end %>
#
#   class ProductsController < ApplicationController
#   def index
#   end
#   end
#
# source://rubocop-rails//lib/rubocop/cop/rails/render_inline.rb#27
class RuboCop::Cop::Rails::RenderInline < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/render_inline.rb#35
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/render_inline.rb#31
  def render_with_inline_option?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/render_inline.rb#28
RuboCop::Cop::Rails::RenderInline::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/render_inline.rb#29
RuboCop::Cop::Rails::RenderInline::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `render text:` can be
# replaced with `render plain:`.
#
# @example
#   # bad - explicit MIME type to `text/plain`
#   render text: 'Ruby!', content_type: 'text/plain'
#
#   # good - short and precise
#   render plain: 'Ruby!'
#
#   # good - explicit MIME type not to `text/plain`
#   render text: 'Ruby!', content_type: 'text/html'
# @example ContentTypeCompatibility: true (default)
#   # good - sets MIME type to `text/html`
#   render text: 'Ruby!'
# @example ContentTypeCompatibility: false
#   # bad - sets MIME type to `text/html`
#   render text: 'Ruby!'
#
# source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#27
class RuboCop::Cop::Rails::RenderPlainText < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#37
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#33
  def render_plain_text?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#56
  def compatible_content_type?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#52
  def find_content_type(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#61
  def replacement(rest_options, option_value); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#30
RuboCop::Cop::Rails::RenderPlainText::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/render_plain_text.rb#31
RuboCop::Cop::Rails::RenderPlainText::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for consistent uses of `request.referer` or
# `request.referrer`, depending on the cop's configuration.
#
# @example EnforcedStyle: referer (default)
#   # bad
#   request.referrer
#
#   # good
#   request.referer
# @example EnforcedStyle: referrer
#   # bad
#   request.referer
#
#   # good
#   request.referrer
#
# source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#22
class RuboCop::Cop::Rails::RequestReferer < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#34
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#30
  def referer?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#46
  def message(_range); end

  # source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#50
  def wrong_method_name; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#26
RuboCop::Cop::Rails::RequestReferer::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/request_referer.rb#28
RuboCop::Cop::Rails::RequestReferer::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks whether the change method of the migration file is
# reversible.
#
# @example
#   # bad
#   def change
#   change_table :users do |t|
#   t.remove :name
#   end
#   end
#
#   # good
#   def change
#   create_table :users do |t|
#   t.string :name
#   end
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   change_table :users do |t|
#   dir.up do
#   t.column :name, :string
#   end
#
#   dir.down do
#   t.remove :name
#   end
#   end
#   end
#   end
# @example
#   # drop_table
#
#   # bad
#   def change
#   drop_table :users
#   end
#
#   # good
#   def change
#   drop_table :users do |t|
#   t.string :name
#   end
#   end
# @example
#   # change_column_default
#
#   # bad
#   def change
#   change_column_default(:suppliers, :qualification, 'new')
#   end
#
#   # good
#   def change
#   change_column_default(:posts, :state, from: nil, to: "draft")
#   end
# @example
#   # remove_column
#
#   # bad
#   def change
#   remove_column(:suppliers, :qualification)
#   end
#
#   # good
#   def change
#   remove_column(:suppliers, :qualification, :string)
#   end
# @example
#   # remove_foreign_key
#
#   # bad
#   def change
#   remove_foreign_key :accounts, column: :owner_id
#   end
#
#   # good
#   def change
#   remove_foreign_key :accounts, :branches
#   end
#
#   # good
#   def change
#   remove_foreign_key :accounts, to_table: :branches
#   end
# @example
#   # change_table
#
#   # bad
#   def change
#   change_table :users do |t|
#   t.remove :name
#   t.change_default :authorized, 1
#   t.change :price, :string
#   end
#   end
#
#   # good
#   def change
#   change_table :users do |t|
#   t.string :name
#   end
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   change_table :users do |t|
#   dir.up do
#   t.change :price, :string
#   end
#
#   dir.down do
#   t.change :price, :integer
#   end
#   end
#   end
#   end
# @example
#   # remove_columns
#
#   # bad
#   def change
#   remove_columns :users, :name, :email
#   end
#
#   # good
#   def change
#   reversible do |dir|
#   dir.up do
#   remove_columns :users, :name, :email
#   end
#
#   dir.down do
#   add_column :users, :name, :string
#   add_column :users, :email, :string
#   end
#   end
#   end
#
#   # good (Rails >= 6.1, see https://github.com/rails/rails/pull/36589)
#   def change
#   remove_columns :users, :name, :email, type: :string
#   end
# @example
#   # remove_index
#
#   # bad
#   def change
#   remove_index :users, name: :index_users_on_email
#   end
#
#   # good
#   def change
#   remove_index :users, :email
#   end
#
#   # good
#   def change
#   remove_index :users, column: :email
#   end
# @see https://api.rubyonrails.org/classes/ActiveRecord/Migration/CommandRecorder.html
#
# source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#178
class RuboCop::Cop::Rails::ReversibleMigration < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#197
  def change_table_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#185
  def drop_table_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#181
  def irreversible_schema_statement_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#222
  def on_block(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#209
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#189
  def remove_column_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#201
  def remove_columns_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#193
  def remove_foreign_key_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#205
  def remove_index_call(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#352
  def all_hash_key?(args, *keys); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#279
  def check_change_table_node(node, block); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#315
  def check_change_table_offense(receiver, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#238
  def check_drop_table_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#232
  def check_irreversible_schema_statement_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#260
  def check_remove_column_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#291
  def check_remove_columns_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#271
  def check_remove_foreign_key_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#304
  def check_remove_index_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#249
  def check_reversible_hash_node(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#326
  def reversible_change_table_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#338
  def within_change_method?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#344
  def within_reversible_or_up_only_block?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/reversible_migration.rb#179
RuboCop::Cop::Rails::ReversibleMigration::MSG = T.let(T.unsafe(nil), String)

# This cop converts usages of `try!` to `&.`. It can also be configured
# to convert `try`. It will convert code to use safe navigation.
#
# @example ConvertTry: false (default)
#   # bad
#   foo.try!(:bar)
#   foo.try!(:bar, baz)
#   foo.try!(:bar) { |e| e.baz }
#
#   foo.try!(:[], 0)
#
#   # good
#   foo.try(:bar)
#   foo.try(:bar, baz)
#   foo.try(:bar) { |e| e.baz }
#
#   foo&.bar
#   foo&.bar(baz)
#   foo&.bar { |e| e.baz }
# @example ConvertTry: true
#   # bad
#   foo.try!(:bar)
#   foo.try!(:bar, baz)
#   foo.try!(:bar) { |e| e.baz }
#   foo.try(:bar)
#   foo.try(:bar, baz)
#   foo.try(:bar) { |e| e.baz }
#
#   # good
#   foo&.bar
#   foo&.bar(baz)
#   foo&.bar { |e| e.baz }
#
# source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#39
class RuboCop::Cop::Rails::SafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#50
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#46
  def try_call(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#63
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#72
  def replacement(method, params); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#43
RuboCop::Cop::Rails::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation.rb#44
RuboCop::Cop::Rails::SafeNavigation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks to make sure safe navigation isn't used with `blank?` in
# a conditional.
#
# While the safe navigation operator is generally a good idea, when
# checking `foo&.blank?` in a conditional, `foo` being `nil` will actually
# do the opposite of what the author intends.
#
# @example
#   # bad
#   do_something if foo&.blank?
#   do_something unless foo&.blank?
#
#   # good
#   do_something if foo.blank?
#   do_something unless foo.blank?
#
# source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation_with_blank.rb#22
class RuboCop::Cop::Rails::SafeNavigationWithBlank < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation_with_blank.rb#33
  def on_if(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation_with_blank.rb#29
  def safe_navigation_blank_in_conditional?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/safe_navigation_with_blank.rb#25
RuboCop::Cop::Rails::SafeNavigationWithBlank::MSG = T.let(T.unsafe(nil), String)

# This cop identifies possible cases where Active Record save! or related
# should be used instead of save because the model might have failed to
# save and an exception is better than unhandled failure.
#
# This will allow:
#
# * update or save calls, assigned to a variable,
#   or used as a condition in an if/unless/case statement.
# * create calls, assigned to a variable that then has a
#   call to `persisted?`, or whose return value is checked by
#   `persisted?` immediately
# * calls if the result is explicitly returned from methods and blocks,
#   or provided as arguments.
# * calls whose signature doesn't look like an ActiveRecord
#   persistence method.
#
# By default it will also allow implicit returns from methods and blocks.
# that behavior can be turned off with `AllowImplicitReturn: false`.
#
# You can permit receivers that are giving false positives with
# `AllowedReceivers: []`
#
# @example
#
#   # bad
#   user.save
#   user.update(name: 'Joe')
#   user.find_or_create_by(name: 'Joe')
#   user.destroy
#
#   # good
#   unless user.save
#   # ...
#   end
#   user.save!
#   user.update!(name: 'Joe')
#   user.find_or_create_by!(name: 'Joe')
#   user.destroy!
#
#   user = User.find_or_create_by(name: 'Joe')
#   unless user.persisted?
#   # ...
#   end
#
#   def save_user
#   return user.save
#   end
# @example AllowImplicitReturn: true (default)
#
#   # good
#   users.each { |u| u.save }
#
#   def save_user
#   user.save
#   end
# @example AllowImplicitReturn: false
#
#   # bad
#   users.each { |u| u.save }
#   def save_user
#   user.save
#   end
#
#   # good
#   users.each { |u| u.save! }
#
#   def save_user
#   user.save!
#   end
#
#   def save_user
#   return user.save
#   end
# @example AllowedReceivers: ['merchant.customers', 'Service::Mailer']
#
#   # bad
#   merchant.create
#   customers.builder.save
#   Mailer.create
#
#   module Service::Mailer
#   self.create
#   end
#
#   # good
#   merchant.customers.create
#   MerchantService.merchant.customers.destroy
#   Service::Mailer.update(message: 'Message')
#   ::Service::Mailer.update
#   Services::Service::Mailer.update(message: 'Message')
#   Service::Mailer::update
#
# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#101
class RuboCop::Cop::Rails::SaveBang < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#123
  def after_leaving_scope(scope, _variable_table); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#131
  def check_assignment(assignment); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#142
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#142
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#244
  def allowed_receiver?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#304
  def argument?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#208
  def array_parent(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#189
  def assignable_node(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#185
  def call_to_persisted?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#215
  def check_used_in_condition_or_compound_boolean(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#240
  def checked_immediately?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#236
  def conditional?(parent); end

  # Const == Const
  # ::Const == ::Const
  # ::Const == Const
  # Const == ::Const
  # NameSpace::Const == Const
  # NameSpace::Const == NameSpace::Const
  # NameSpace::Const != ::Const
  # Const != NameSpace::Const
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#277
  def const_matches?(const, allowed_const); end

  # Check argument signature as no arguments or one hash
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#325
  def expected_signature?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#308
  def explicit_return?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#296
  def find_method_with_sibling_index(node, sibling_index = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#198
  def hash_parent(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#286
  def implicit_return?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#223
  def in_condition_or_compound_boolean?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#232
  def operator_or_single_negative?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#318
  def persist_method?(node, methods = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#177
  def persisted_referenced?(assignment); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#254
  def receiver_chain_matches?(node, allowed_receiver); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#158
  def register_offense(node, msg); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#313
  def return_value_assigned?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#169
  def right_assignment_node(assignment); end

  class << self
    # source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#119
    def joining_forces; end
  end
end

# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#110
RuboCop::Cop::Rails::SaveBang::CREATE_CONDITIONAL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#107
RuboCop::Cop::Rails::SaveBang::CREATE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#113
RuboCop::Cop::Rails::SaveBang::CREATE_PERSIST_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#115
RuboCop::Cop::Rails::SaveBang::MODIFY_PERSIST_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#105
RuboCop::Cop::Rails::SaveBang::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/save_bang.rb#117
RuboCop::Cop::Rails::SaveBang::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for scope calls where it was passed
# a method (usually a scope) instead of a lambda/proc.
#
# @example
#
#   # bad
#   scope :something, where(something: true)
#
#   # good
#   scope :something, -> { where(something: true) }
#
# source://rubocop-rails//lib/rubocop/cop/rails/scope_args.rb#16
class RuboCop::Cop::Rails::ScopeArgs < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/scope_args.rb#22
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/scope_args.rb#20
  def scope?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/scope_args.rb#17
RuboCop::Cop::Rails::ScopeArgs::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/scope_args.rb#18
RuboCop::Cop::Rails::ScopeArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces that short forms of `I18n` methods are used:
# `t` instead of `translate` and `l` instead of `localize`.
#
# This cop has two different enforcement modes. When the EnforcedStyle
# is conservative (the default) then only `I18n.translate` and `I18n.localize`
# calls are added as offenses.
#
# When the EnforcedStyle is aggressive then all `translate` and `localize` calls
# without a receiver are added as offenses.
#
# @example
#   # bad
#   I18n.translate :key
#   I18n.localize Time.now
#
#   # good
#   I18n.t :key
#   I18n.l Time.now
# @example EnforcedStyle: conservative (default)
#   # good
#   translate :key
#   localize Time.now
#   t :key
#   l Time.now
# @example EnforcedStyle: aggressive
#   # bad
#   translate :key
#   localize Time.now
#
#   # good
#   t :key
#   l Time.now
#
# source://rubocop-rails//lib/rubocop/cop/rails/short_i18n.rb#41
class RuboCop::Cop::Rails::ShortI18n < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/short_i18n.rb#54
  def long_i18n?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/short_i18n.rb#58
  def on_send(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/short_i18n.rb#45
RuboCop::Cop::Rails::ShortI18n::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/short_i18n.rb#47
RuboCop::Cop::Rails::ShortI18n::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/cop/rails/short_i18n.rb#52
RuboCop::Cop::Rails::ShortI18n::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for the use of methods which skip
# validations which are listed in
# https://guides.rubyonrails.org/active_record_validations.html#skipping-validations
#
# Methods may be ignored from this rule by configuring a `AllowedMethods`.
#
# @example
#   # bad
#   Article.first.decrement!(:view_count)
#   DiscussionBoard.decrement_counter(:post_count, 5)
#   Article.first.increment!(:view_count)
#   DiscussionBoard.increment_counter(:post_count, 5)
#   person.toggle :active
#   product.touch
#   Billing.update_all("category = 'authorized', author = 'David'")
#   user.update_attribute(:website, 'example.com')
#   user.update_columns(last_request_at: Time.current)
#   Post.update_counters 5, comment_count: -1, action_count: 1
#
#   # good
#   user.update(website: 'example.com')
#   FileUtils.touch('file')
# @example AllowedMethods: ["touch"]
#   # bad
#   DiscussionBoard.decrement_counter(:post_count, 5)
#   DiscussionBoard.increment_counter(:post_count, 5)
#   person.toggle :active
#
#   # good
#   user.touch
#
# source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#38
class RuboCop::Cop::Rails::SkipsModelValidations < ::RuboCop::Cop::Base
  # @return [SkipsModelValidations] a new instance of SkipsModelValidations
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#83
  def initialize(*_arg0); end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#65
  def good_insert?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#58
  def good_touch?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#72
  def on_csend(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#72
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#95
  def allowed_method?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#111
  def allowed_methods; end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#100
  def forbidden_methods; end

  # source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#91
  def message(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#41
RuboCop::Cop::Rails::SkipsModelValidations::METHODS_WITH_ARGUMENTS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/skips_model_validations.rb#39
RuboCop::Cop::Rails::SkipsModelValidations::MSG = T.let(T.unsafe(nil), String)

# Checks SQL heredocs to use `.squish`.
# Some SQL syntax (e.g. PostgreSQL comments and functions) requires newlines
# to be preserved in order to work, thus auto-correction for this cop is not safe.
#
# @example
#   # bad
#   <<-SQL
#   SELECT * FROM posts;
#   SQL
#
#   <<-SQL
#   SELECT * FROM posts
#   WHERE id = 1
#   SQL
#
#   execute(<<~SQL, "Post Load")
#   SELECT * FROM posts
#   WHERE post_id = 1
#   SQL
#
#   # good
#   <<-SQL.squish
#   SELECT * FROM posts;
#   SQL
#
#   <<~SQL.squish
#   SELECT * FROM table
#   WHERE id = 1
#   SQL
#
#   execute(<<~SQL.squish, "Post Load")
#   SELECT * FROM posts
#   WHERE post_id = 1
#   SQL
#
# source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#42
class RuboCop::Cop::Rails::SquishedSQLHeredocs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#50
  def on_heredoc(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#72
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#60
  def offense_detected?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#64
  def sql_heredoc?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#68
  def using_squish?(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#48
RuboCop::Cop::Rails::SquishedSQLHeredocs::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#46
RuboCop::Cop::Rails::SquishedSQLHeredocs::SQL = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/squished_sql_heredocs.rb#47
RuboCop::Cop::Rails::SquishedSQLHeredocs::SQUISH = T.let(T.unsafe(nil), String)

# This cop checks for the use of Time methods without zone.
#
# Built on top of Ruby on Rails style guide (https://rails.rubystyle.guide#time)
# and the article http://danilenko.org/2012/7/6/rails_timezones/
#
# Two styles are supported for this cop. When EnforcedStyle is 'strict'
# then only use of Time.zone is allowed.
#
# When EnforcedStyle is 'flexible' then it's also allowed
# to use Time.in_time_zone.
#
# @example EnforcedStyle: strict
#   # `strict` means that `Time` should be used with `zone`.
#
#   # bad
#   Time.now
#   Time.parse('2015-03-02 19:05:37')
#
#   # bad
#   Time.current
#   Time.at(timestamp).in_time_zone
#
#   # good
#   Time.zone.now
#   Time.zone.parse('2015-03-02 19:05:37')
# @example EnforcedStyle: flexible (default)
#   # `flexible` allows usage of `in_time_zone` instead of `zone`.
#
#   # bad
#   Time.now
#   Time.parse('2015-03-02 19:05:37')
#
#   # good
#   Time.zone.now
#   Time.zone.parse('2015-03-02 19:05:37')
#
#   # good
#   Time.current
#   Time.at(timestamp).in_time_zone
#
# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#46
class RuboCop::Cop::Rails::TimeZone < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#66
  def on_const(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#226
  def acceptable_methods(klass, method_name, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#77
  def autocorrect(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#94
  def autocorrect_time_new(node, corrector); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#135
  def build_message(klass, method_name, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#186
  def check_localtime(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#118
  def check_time_node(klass, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#150
  def extract_method_chain(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#210
  def flexible?; end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#218
  def good_methods; end

  # Only add the method to the chain if the method being
  # called is part of the time class.
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#161
  def method_from_time_class?(node); end

  # checks that parent node of send_type
  # and receiver is the given node
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#172
  def method_send?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#206
  def need_check_localtime?(chain); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#202
  def not_danger_chain?(chain); end

  # Time.new can be called with a time zone offset
  # When it is, that should be considered safe
  # Example:
  # Time.new(1988, 3, 15, 3, 0, 0, "-05:00")
  #
  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#243
  def offset_provided?(node); end

  # remove redundant `.in_time_zone` from `Time.zone.now.in_time_zone`
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#103
  def remove_redundant_in_time_zone(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#178
  def safe_method(method_name, node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#214
  def strict?; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#63
RuboCop::Cop::Rails::TimeZone::ACCEPTED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#61
RuboCop::Cop::Rails::TimeZone::DANGEROUS_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#59
RuboCop::Cop::Rails::TimeZone::GOOD_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#50
RuboCop::Cop::Rails::TimeZone::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#53
RuboCop::Cop::Rails::TimeZone::MSG_ACCEPTABLE = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/time_zone.rb#56
RuboCop::Cop::Rails::TimeZone::MSG_LOCALTIME = T.let(T.unsafe(nil), String)

# Prefer the use of distinct, before pluck instead of after.
#
# The use of distinct before pluck is preferred because it executes within
# the database.
#
# This cop has two different enforcement modes. When the EnforcedStyle
# is conservative (the default) then only calls to pluck on a constant
# (i.e. a model class) before distinct are added as offenses.
#
# When the EnforcedStyle is aggressive then all calls to pluck before
# distinct are added as offenses. This may lead to false positives
# as the cop cannot distinguish between calls to pluck on an
# ActiveRecord::Relation vs a call to pluck on an
# ActiveRecord::Associations::CollectionProxy.
#
# This cop is unsafe because the behavior may change depending on the
# database collation.
# Autocorrect is disabled by default for this cop since it may generate
# false positives.
#
# @example EnforcedStyle: conservative (default)
#   # bad
#   Model.pluck(:id).uniq
#
#   # good
#   Model.distinct.pluck(:id)
# @example EnforcedStyle: aggressive
#   # bad
#   # this will return a Relation that pluck is called on
#   Model.where(cond: true).pluck(:id).uniq
#
#   # bad
#   # an association on an instance will return a CollectionProxy
#   instance.assoc.pluck(:id).uniq
#
#   # bad
#   Model.pluck(:id).uniq
#
#   # good
#   Model.distinct.pluck(:id)
#
# source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#48
class RuboCop::Cop::Rails::UniqBeforePluck < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#62
  def aggressive_node_match(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#59
  def conservative_node_match(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#65
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#93
  def dot_method_begin_pos(method, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#88
  def dot_method_with_whitespace(method, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#84
  def style_parameter_name; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#53
RuboCop::Cop::Rails::UniqBeforePluck::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#55
RuboCop::Cop::Rails::UniqBeforePluck::NEWLINE = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#56
RuboCop::Cop::Rails::UniqBeforePluck::PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/uniq_before_pluck.rb#54
RuboCop::Cop::Rails::UniqBeforePluck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# When you define a uniqueness validation in Active Record model,
# you also should add a unique index for the column. There are two reasons
# First, duplicated records may occur even if Active Record's validation
# is defined.
# Second, it will cause slow queries. The validation executes a `SELECT`
# statement with the target column when inserting/updating a record.
# If the column does not have an index and the table is large,
# the query will be heavy.
#
# Note that the cop does nothing if db/schema.rb does not exist.
#
# @example
#   # bad - if the schema does not have a unique index
#   validates :account, uniqueness: true
#
#   # good - if the schema has a unique index
#   validates :account, uniqueness: true
#
#   # good - even if the schema does not have a unique index
#   validates :account, length: { minimum: MIN_LENGTH }
#
# source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#27
class RuboCop::Cop::Rails::UniqueValidationWithoutIndex < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ActiveRecordHelper

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#33
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#152
  def array_node_to_array(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#125
  def class_node(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#76
  def column_names(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#95
  def column_names_from_scope(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#140
  def condition_part?(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#47
  def find_schema_information(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#112
  def find_scope(pairs); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#68
  def include_column_names_in_expression_index?(index, column_names); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#121
  def unfreeze_scope(scope); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#129
  def uniqueness_part(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#57
  def with_index?(klass, table, names); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#30
RuboCop::Cop::Rails::UniqueValidationWithoutIndex::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/unique_validation_without_index.rb#31
RuboCop::Cop::Rails::UniqueValidationWithoutIndex::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks that environments called with `Rails.env` predicates
# exist.
# By default the cop allows three environments which Rails ships with:
# `development`, `test`, and `production`.
# More can be added to the `Environments` config parameter.
#
# @example
#   # bad
#   Rails.env.proudction?
#   Rails.env == 'proudction'
#
#   # good
#   Rails.env.production?
#   Rails.env == 'production'
#
# source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#20
class RuboCop::Cop::Rails::UnknownEnv < ::RuboCop::Cop::Base
  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#42
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#25
  def rails_env?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#35
  def unknown_environment_equal?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#31
  def unknown_environment_predicate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#55
  def collect_variable_like_names(_scope); end

  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#90
  def environments; end

  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#59
  def message(name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#86
  def unknown_env_name?(name); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#80
  def unknown_env_predicate?(name); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#21
RuboCop::Cop::Rails::UnknownEnv::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/unknown_env.rb#22
RuboCop::Cop::Rails::UnknownEnv::MSG_SIMILAR = T.let(T.unsafe(nil), String)

# This cop checks for the use of old-style attribute validation macros.
#
# @example
#   # bad
#   validates_acceptance_of :foo
#   validates_confirmation_of :foo
#   validates_exclusion_of :foo
#   validates_format_of :foo
#   validates_inclusion_of :foo
#   validates_length_of :foo
#   validates_numericality_of :foo
#   validates_presence_of :foo
#   validates_absence_of :foo
#   validates_size_of :foo
#   validates_uniqueness_of :foo
#
#   # good
#   validates :foo, acceptance: true
#   validates :foo, confirmation: true
#   validates :foo, exclusion: true
#   validates :foo, format: true
#   validates :foo, inclusion: true
#   validates :foo, length: true
#   validates :foo, numericality: true
#   validates :foo, presence: true
#   validates :foo, absence: true
#   validates :foo, size: true
#   validates :foo, uniqueness: true
#
# source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#35
class RuboCop::Cop::Rails::Validation < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#58
  def on_send(node); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#138
  def braced_options(options); end

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#85
  def correct_validate_type(corrector, node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#113
  def correct_validate_type_for_array(corrector, node, arguments, loc); end

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#106
  def correct_validate_type_for_hash(corrector, node, arguments); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#134
  def frozen_array_argument?(argument); end

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#75
  def message(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#81
  def preferred_method(method); end

  # source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#130
  def validate_type(node); end
end

# source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#56
RuboCop::Cop::Rails::Validation::ALLOWLIST = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#38
RuboCop::Cop::Rails::Validation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#55
RuboCop::Cop::Rails::Validation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rails//lib/rubocop/cop/rails/validation.rb#41
RuboCop::Cop::Rails::Validation::TYPES = T.let(T.unsafe(nil), Array)

# This cop identifies places where manually constructed SQL
# in `where` can be replaced with `where(attribute: value)`.
#
# @example
#   # bad
#   User.where('name = ?', 'Gabe')
#   User.where('name = :name', name: 'Gabe')
#   User.where('name IS NULL')
#   User.where('name IN (?)', ['john', 'jane'])
#   User.where('name IN (:names)', names: ['john', 'jane'])
#   User.where('users.name = :name', name: 'Gabe')
#
#   # good
#   User.where(name: 'Gabe')
#   User.where(name: nil)
#   User.where(name: ['john', 'jane'])
#   User.where(users: { name: 'Gabe' })
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#23
class RuboCop::Cop::Rails::WhereEquals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#37
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#30
  def where_method_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#86
  def build_good_method(column, value); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#67
  def extract_column_and_value(template_node, value_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#63
  def offense_range(node); end
end

# column = ?
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#55
RuboCop::Cop::Rails::WhereEquals::EQ_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column = :column
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#57
RuboCop::Cop::Rails::WhereEquals::EQ_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# column IN (?)
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#56
RuboCop::Cop::Rails::WhereEquals::IN_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column IN (:column)
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#58
RuboCop::Cop::Rails::WhereEquals::IN_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# column IS NULL
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#59
RuboCop::Cop::Rails::WhereEquals::IS_NULL_RE = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#27
RuboCop::Cop::Rails::WhereEquals::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/where_equals.rb#28
RuboCop::Cop::Rails::WhereEquals::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop enforces consistent style when using `exists?`.
#
# Two styles are supported for this cop. When EnforcedStyle is 'exists'
# then the cop enforces `exists?(...)` over `where(...).exists?`.
#
# When EnforcedStyle is 'where' then the cop enforces
# `where(...).exists?` over `exists?(...)`.
#
# @example EnforcedStyle: exists (default)
#   # bad
#   User.where(name: 'john').exists?
#   User.where(['name = ?', 'john']).exists?
#   User.where('name = ?', 'john').exists?
#   user.posts.where(published: true).exists?
#
#   # good
#   User.exists?(name: 'john')
#   User.where('length(name) > 10').exists?
#   user.posts.exists?(published: true)
# @example EnforcedStyle: where
#   # bad
#   User.exists?(name: 'john')
#   User.exists?(['name = ?', 'john'])
#   User.exists?('name = ?', 'john')
#   user.posts.exists?(published: true)
#
#   # good
#   User.where(name: 'john').exists?
#   User.where(['name = ?', 'john']).exists?
#   User.where('name = ?', 'john').exists?
#   user.posts.where(published: true).exists?
#   User.where('length(name) > 10').exists?
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#39
class RuboCop::Cop::Rails::WhereExists < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#50
  def exists_with_args?(param0 = T.unsafe(nil)); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#54
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#46
  def where_exists_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#100
  def build_good_method(args); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#108
  def build_good_method_exists(args); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#116
  def build_good_method_where(args); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#86
  def convertable_args?(args); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#92
  def correction_range(node); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#74
  def exists_style?; end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#78
  def find_offenses(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#70
  def where_style?; end
end

# source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#43
RuboCop::Cop::Rails::WhereExists::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rails//lib/rubocop/cop/rails/where_exists.rb#44
RuboCop::Cop::Rails::WhereExists::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where manually constructed SQL
# in `where` can be replaced with `where.not(...)`.
#
# @example
#   # bad
#   User.where('name != ?', 'Gabe')
#   User.where('name != :name', name: 'Gabe')
#   User.where('name <> ?', 'Gabe')
#   User.where('name <> :name', name: 'Gabe')
#   User.where('name IS NOT NULL')
#   User.where('name NOT IN (?)', ['john', 'jane'])
#   User.where('name NOT IN (:names)', names: ['john', 'jane'])
#
#   # good
#   User.where.not(name: 'Gabe')
#   User.where.not(name: nil)
#   User.where.not(name: ['john', 'jane'])
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#24
class RuboCop::Cop::Rails::WhereNot < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#38
  def on_send(node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#31
  def where_method_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#87
  def build_good_method(column, value); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#68
  def extract_column_and_value(template_node, value_node); end

  # source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#64
  def offense_range(node); end
end

# column IS NOT NULL
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#60
RuboCop::Cop::Rails::WhereNot::IS_NOT_NULL_RE = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#28
RuboCop::Cop::Rails::WhereNot::MSG = T.let(T.unsafe(nil), String)

# column != ?, column <> ?
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#56
RuboCop::Cop::Rails::WhereNot::NOT_EQ_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column != :column, column <> :column
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#58
RuboCop::Cop::Rails::WhereNot::NOT_EQ_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# column NOT IN (?)
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#57
RuboCop::Cop::Rails::WhereNot::NOT_IN_ANONYMOUS_RE = T.let(T.unsafe(nil), Regexp)

# column NOT IN (:column)
#
# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#59
RuboCop::Cop::Rails::WhereNot::NOT_IN_NAMED_RE = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rails//lib/rubocop/cop/rails/where_not.rb#29
RuboCop::Cop::Rails::WhereNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Common functionality for checking target rails version.
#
# source://rubocop-rails//lib/rubocop/cop/mixin/target_rails_version.rb#6
module RuboCop::Cop::TargetRailsVersion
  # source://rubocop-rails//lib/rubocop/cop/mixin/target_rails_version.rb#7
  def minimum_target_rails_version(version); end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/cop/mixin/target_rails_version.rb#11
  def support_target_rails_version?(version); end
end

# RuboCop Rails project namespace
#
# source://rubocop-rails//lib/rubocop/rails.rb#5
module RuboCop::Rails; end

# source://rubocop-rails//lib/rubocop/rails.rb#8
RuboCop::Rails::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-rails//lib/rubocop/rails.rb#7
RuboCop::Rails::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-rails//lib/rubocop/rails/inject.rb#7
module RuboCop::Rails::Inject
  class << self
    # source://rubocop-rails//lib/rubocop/rails/inject.rb#8
    def defaults!; end
  end
end

# source://rubocop-rails//lib/rubocop/rails.rb#6
RuboCop::Rails::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# It loads db/schema.rb and return Schema object.
# Cops refers database schema information with this module.
#
# source://rubocop-rails//lib/rubocop/rails/schema_loader.rb#7
module RuboCop::Rails::SchemaLoader
  extend ::RuboCop::Rails::SchemaLoader

  # source://rubocop-rails//lib/rubocop/rails/schema_loader.rb#27
  def db_schema_path; end

  # It parses `db/schema.rb` and return it.
  # It returns `nil` if it can't find `db/schema.rb`.
  # So a cop that uses the loader should handle `nil` properly.
  #
  # @return [Schema, nil]
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader.rb#15
  def load(target_ruby_version); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader.rb#21
  def reset!; end

  private

  # source://rubocop-rails//lib/rubocop/rails/schema_loader.rb#41
  def load!(target_ruby_version); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader.rb#49
  def parse(path, target_ruby_version); end
end

# Represent an `add_index`
#
# source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#175
class RuboCop::Rails::SchemaLoader::AddIndex < ::RuboCop::Rails::SchemaLoader::Index
  # @return [AddIndex] a new instance of AddIndex
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#178
  def initialize(node); end

  # Returns the value of attribute table_name.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#176
  def table_name; end
end

# Represent a column
#
# source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#113
class RuboCop::Rails::SchemaLoader::Column
  # @return [Column] a new instance of Column
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#116
  def initialize(node); end

  # Returns the value of attribute name.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#114
  def name; end

  # Returns the value of attribute not_null.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#114
  def not_null; end

  # Returns the value of attribute type.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#114
  def type; end

  private

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#126
  def analyze_keywords!(node); end
end

# Represent an index
#
# source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#139
class RuboCop::Rails::SchemaLoader::Index
  # @return [Index] a new instance of Index
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#142
  def initialize(node); end

  # Returns the value of attribute columns.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#140
  def columns; end

  # Returns the value of attribute expression.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#140
  def expression; end

  # Returns the value of attribute name.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#140
  def name; end

  # Returns the value of attribute unique.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#140
  def unique; end

  private

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#159
  def analyze_keywords!(node); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#151
  def build_columns_or_expr(columns); end
end

# Represent db/schema.rb
#
# source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#7
class RuboCop::Rails::SchemaLoader::Schema
  # @return [Schema] a new instance of Schema
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#10
  def initialize(ast); end

  # Returns the value of attribute add_indicies.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#8
  def add_indicies; end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#23
  def add_indicies_by(table_name:); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#17
  def table_by(name:); end

  # Returns the value of attribute tables.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#8
  def tables; end

  private

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#31
  def build!(ast); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#57
  def each_add_index(ast); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#44
  def each_table(ast); end
end

# Represent a table
#
# source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#67
class RuboCop::Rails::SchemaLoader::Table
  # @return [Table] a new instance of Table
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#70
  def initialize(node); end

  # Returns the value of attribute columns.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#68
  def columns; end

  # Returns the value of attribute indices.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#68
  def indices; end

  # Returns the value of attribute name.
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#68
  def name; end

  # @return [Boolean]
  #
  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#76
  def with_column?(name:); end

  private

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#82
  def build_columns(node); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#91
  def build_indices(node); end

  # source://rubocop-rails//lib/rubocop/rails/schema_loader/schema.rb#100
  def each_content(node, &block); end
end

# This module holds the RuboCop Rails version information.
#
# source://rubocop-rails//lib/rubocop/rails/version.rb#6
module RuboCop::Rails::Version
  class << self
    # source://rubocop-rails//lib/rubocop/rails/version.rb#9
    def document_version; end
  end
end

# source://rubocop-rails//lib/rubocop/rails/version.rb#7
RuboCop::Rails::Version::STRING = T.let(T.unsafe(nil), String)
